<!DOCTYPE html>

<html>
<head>
  <title>Scrawl-canvas filters web worker</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, target-densitydpi=160dpi, initial-scale=1.0; maximum-scale=1.0; user-scalable=0;">
  <link rel="stylesheet" media="all" href="../../docco.css" />
</head>
<body>
  <div id="container">
    <div id="background"></div>
    
      <ul id="jump_to">
        <li>
          <a class="large" href="javascript:void(0);">Jump To &hellip;</a>
          <a class="small" href="javascript:void(0);">+</a>
          <div id="jump_wrapper">
          <div id="jump_page_wrapper">
            <div id="jump_page">
              
                
                <a class="source" href="../core/animationloop.html">
                  ./source/core/animationloop.js
                </a>
              
                
                <a class="source" href="../core/component.html">
                  ./source/core/component.js
                </a>
              
                
                <a class="source" href="../core/document.html">
                  ./source/core/document.js
                </a>
              
                
                <a class="source" href="../core/events.html">
                  ./source/core/events.js
                </a>
              
                
                <a class="source" href="../core/init.html">
                  ./source/core/init.js
                </a>
              
                
                <a class="source" href="../core/library.html">
                  ./source/core/library.js
                </a>
              
                
                <a class="source" href="../core/userInteraction.html">
                  ./source/core/userInteraction.js
                </a>
              
                
                <a class="source" href="../core/utilities.html">
                  ./source/core/utilities.js
                </a>
              
                
                <a class="source" href="action.html">
                  ./source/factory/action.js
                </a>
              
                
                <a class="source" href="anchor.html">
                  ./source/factory/anchor.js
                </a>
              
                
                <a class="source" href="animation.html">
                  ./source/factory/animation.js
                </a>
              
                
                <a class="source" href="bezier.html">
                  ./source/factory/bezier.js
                </a>
              
                
                <a class="source" href="block.html">
                  ./source/factory/block.js
                </a>
              
                
                <a class="source" href="canvas.html">
                  ./source/factory/canvas.js
                </a>
              
                
                <a class="source" href="cell.html">
                  ./source/factory/cell.js
                </a>
              
                
                <a class="source" href="cog.html">
                  ./source/factory/cog.js
                </a>
              
                
                <a class="source" href="color.html">
                  ./source/factory/color.js
                </a>
              
                
                <a class="source" href="coordinate.html">
                  ./source/factory/coordinate.js
                </a>
              
                
                <a class="source" href="element.html">
                  ./source/factory/element.js
                </a>
              
                
                <a class="source" href="emitter.html">
                  ./source/factory/emitter.js
                </a>
              
                
                <a class="source" href="filter.html">
                  ./source/factory/filter.js
                </a>
              
                
                <a class="source" href="filterEngine.html">
                  ./source/factory/filterEngine.js
                </a>
              
                
                <a class="source" href="fontAttributes.html">
                  ./source/factory/fontAttributes.js
                </a>
              
                
                <a class="source" href="gradient.html">
                  ./source/factory/gradient.js
                </a>
              
                
                <a class="source" href="grid.html">
                  ./source/factory/grid.js
                </a>
              
                
                <a class="source" href="group.html">
                  ./source/factory/group.js
                </a>
              
                
                <a class="source" href="imageAsset.html">
                  ./source/factory/imageAsset.js
                </a>
              
                
                <a class="source" href="line.html">
                  ./source/factory/line.js
                </a>
              
                
                <a class="source" href="loom.html">
                  ./source/factory/loom.js
                </a>
              
                
                <a class="source" href="mesh.html">
                  ./source/factory/mesh.js
                </a>
              
                
                <a class="source" href="net.html">
                  ./source/factory/net.js
                </a>
              
                
                <a class="source" href="noise.html">
                  ./source/factory/noise.js
                </a>
              
                
                <a class="source" href="oval.html">
                  ./source/factory/oval.js
                </a>
              
                
                <a class="source" href="palette.html">
                  ./source/factory/palette.js
                </a>
              
                
                <a class="source" href="particle.html">
                  ./source/factory/particle.js
                </a>
              
                
                <a class="source" href="particleForce.html">
                  ./source/factory/particleForce.js
                </a>
              
                
                <a class="source" href="particleHistory.html">
                  ./source/factory/particleHistory.js
                </a>
              
                
                <a class="source" href="particleSpring.html">
                  ./source/factory/particleSpring.js
                </a>
              
                
                <a class="source" href="particleWorld.html">
                  ./source/factory/particleWorld.js
                </a>
              
                
                <a class="source" href="pattern.html">
                  ./source/factory/pattern.js
                </a>
              
                
                <a class="source" href="phrase.html">
                  ./source/factory/phrase.js
                </a>
              
                
                <a class="source" href="picture.html">
                  ./source/factory/picture.js
                </a>
              
                
                <a class="source" href="polygon.html">
                  ./source/factory/polygon.js
                </a>
              
                
                <a class="source" href="polyline.html">
                  ./source/factory/polyline.js
                </a>
              
                
                <a class="source" href="quadratic.html">
                  ./source/factory/quadratic.js
                </a>
              
                
                <a class="source" href="quaternion.html">
                  ./source/factory/quaternion.js
                </a>
              
                
                <a class="source" href="radialGradient.html">
                  ./source/factory/radialGradient.js
                </a>
              
                
                <a class="source" href="rectangle.html">
                  ./source/factory/rectangle.js
                </a>
              
                
                <a class="source" href="renderAnimation.html">
                  ./source/factory/renderAnimation.js
                </a>
              
                
                <a class="source" href="shape.html">
                  ./source/factory/shape.js
                </a>
              
                
                <a class="source" href="spiral.html">
                  ./source/factory/spiral.js
                </a>
              
                
                <a class="source" href="spriteAsset.html">
                  ./source/factory/spriteAsset.js
                </a>
              
                
                <a class="source" href="stack.html">
                  ./source/factory/stack.js
                </a>
              
                
                <a class="source" href="star.html">
                  ./source/factory/star.js
                </a>
              
                
                <a class="source" href="state.html">
                  ./source/factory/state.js
                </a>
              
                
                <a class="source" href="tetragon.html">
                  ./source/factory/tetragon.js
                </a>
              
                
                <a class="source" href="ticker.html">
                  ./source/factory/ticker.js
                </a>
              
                
                <a class="source" href="tracer.html">
                  ./source/factory/tracer.js
                </a>
              
                
                <a class="source" href="tween.html">
                  ./source/factory/tween.js
                </a>
              
                
                <a class="source" href="unstackedElement.html">
                  ./source/factory/unstackedElement.js
                </a>
              
                
                <a class="source" href="vector.html">
                  ./source/factory/vector.js
                </a>
              
                
                <a class="source" href="videoAsset.html">
                  ./source/factory/videoAsset.js
                </a>
              
                
                <a class="source" href="wheel.html">
                  ./source/factory/wheel.js
                </a>
              
                
                <a class="source" href="../mixin/anchor.html">
                  ./source/mixin/anchor.js
                </a>
              
                
                <a class="source" href="../mixin/asset.html">
                  ./source/mixin/asset.js
                </a>
              
                
                <a class="source" href="../mixin/assetConsumer.html">
                  ./source/mixin/assetConsumer.js
                </a>
              
                
                <a class="source" href="../mixin/base.html">
                  ./source/mixin/base.js
                </a>
              
                
                <a class="source" href="../mixin/cascade.html">
                  ./source/mixin/cascade.js
                </a>
              
                
                <a class="source" href="../mixin/delta.html">
                  ./source/mixin/delta.js
                </a>
              
                
                <a class="source" href="../mixin/displayShape.html">
                  ./source/mixin/displayShape.js
                </a>
              
                
                <a class="source" href="../mixin/dom.html">
                  ./source/mixin/dom.js
                </a>
              
                
                <a class="source" href="../mixin/entity.html">
                  ./source/mixin/entity.js
                </a>
              
                
                <a class="source" href="../mixin/filter.html">
                  ./source/mixin/filter.js
                </a>
              
                
                <a class="source" href="../mixin/mimic.html">
                  ./source/mixin/mimic.js
                </a>
              
                
                <a class="source" href="../mixin/path.html">
                  ./source/mixin/path.js
                </a>
              
                
                <a class="source" href="../mixin/pattern.html">
                  ./source/mixin/pattern.js
                </a>
              
                
                <a class="source" href="../mixin/pivot.html">
                  ./source/mixin/pivot.js
                </a>
              
                
                <a class="source" href="../mixin/position.html">
                  ./source/mixin/position.js
                </a>
              
                
                <a class="source" href="../mixin/shapeBasic.html">
                  ./source/mixin/shapeBasic.js
                </a>
              
                
                <a class="source" href="../mixin/shapeCurve.html">
                  ./source/mixin/shapeCurve.js
                </a>
              
                
                <a class="source" href="../mixin/shapePathCalculation.html">
                  ./source/mixin/shapePathCalculation.js
                </a>
              
                
                <a class="source" href="../mixin/styles.html">
                  ./source/mixin/styles.js
                </a>
              
                
                <a class="source" href="../mixin/tween.html">
                  ./source/mixin/tween.js
                </a>
              
            </div>
          </div>
        </li>
      </ul>
    
    <ul class="sections">
        
        
        
        <li id="section-1">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-1">&#x00a7;</a>
              </div>
              <h1 id="scrawl-canvas-filters-web-worker">Scrawl-canvas filters web worker</h1>
<p>This web worker code is called in a just-in-time manner; the code will not be requested from the server until a Scrawl-canvas entity, Group or Cell with a non-zero <code>filters</code> attribute is processed during the Display cycle. </p>
<p>All Scrawl-canvas filters-related image manipulation work happens in this worker code. Note that this functionality is entirely separate from the &lt;canvas&gt; element’s context engine’s native <code>filter</code> functionality, which allows us to add CSS/SVG-based filters to the canvas context</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>

<span class="hljs-keyword">import</span> { <span class="hljs-title">constructors</span> } <span class="hljs-title">from</span> &#x27;../<span class="hljs-title">core</span>/<span class="hljs-title">library</span>.<span class="hljs-title">js</span>&#x27;;</pre></div></div>
            
        </li>
        
        
        <li id="section-2">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-2">&#x00a7;</a>
              </div>
              <h4 id="filterengine-constructor">FilterEngine constructor</h4>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-keyword">const</span> FilterEngine = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-3">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-3">&#x00a7;</a>
              </div>
              <h3 id="transactional-variables">Transactional variables</h3>

            </div>
            
        </li>
        
        
        <li id="section-4">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-4">&#x00a7;</a>
              </div>
              <p><strong>image</strong> - the original imageData <code>{width, height, data}</code> object supplied in the message</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-built_in">this</span>.image = <span class="hljs-literal">null</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-5">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-5">&#x00a7;</a>
              </div>
              <p><strong>cache</strong> - an Object consisting of <code>key:Object</code> pairs where the key is the named input of a <code>process-image</code> action or the output of any action object. This object is cleared and re-initialized each time the worker receives a new message</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-built_in">this</span>.cache = <span class="hljs-literal">null</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-6">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-6">&#x00a7;</a>
              </div>
              <p><strong>actions</strong> - the Array of action objects that the worker needs to process - data supplied by the main thread in its message’s <code>packetFiltersArray</code> attribute.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-built_in">this</span>.actions = [];

    <span class="hljs-built_in">this</span>.choke = <span class="hljs-number">3000</span>;

    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;
};</pre></div></div>
            
        </li>
        
        
        <li id="section-7">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-7">&#x00a7;</a>
              </div>
              <h4 id="filterengine-prototype">FilterEngine prototype</h4>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-keyword">let</span> P = FilterEngine.prototype = <span class="hljs-built_in">Object</span>.create(<span class="hljs-built_in">Object</span>.prototype);
P.type = <span class="hljs-string">&#x27;FilterEngine&#x27;</span>;

P.action = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">packet</span>) </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-8">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-8">&#x00a7;</a>
              </div>
              <p>logMessage(‘actioning some filters’);</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
    <span class="hljs-keyword">let</span> { filters, image } = packet;

    <span class="hljs-built_in">this</span>.image = image;

    <span class="hljs-keyword">let</span> { workstoreLastAccessed, workstore, actions, choke, theBigActionsObject } = <span class="hljs-built_in">this</span>;

    <span class="hljs-keyword">let</span> workstoreKeys = <span class="hljs-built_in">Object</span>.keys(workstore), 
        workstoreChoke = <span class="hljs-built_in">Date</span>.now() - choke;

    workstoreKeys.forEach(<span class="hljs-function"><span class="hljs-params">k</span> =&gt;</span> {

        <span class="hljs-keyword">if</span> (workstoreLastAccessed[k] &lt; workstoreChoke) {

            <span class="hljs-keyword">delete</span> workstore[k];
            <span class="hljs-keyword">delete</span> workstoreLastAccessed[k];
        }
    });

    <span class="hljs-built_in">this</span>.cache = {};

    actions.length = <span class="hljs-number">0</span>;
    filters.forEach(<span class="hljs-function"><span class="hljs-params">f</span> =&gt;</span> actions.push(...f.actions));

    <span class="hljs-keyword">if</span> (actions.length) {

        <span class="hljs-built_in">this</span>.unknit(image);
        actions.forEach(<span class="hljs-function"><span class="hljs-params">a</span> =&gt;</span> theBigActionsObject[a.action] &amp;&amp; theBigActionsObject[a.action].call(<span class="hljs-built_in">this</span>, a));
        <span class="hljs-built_in">this</span>.knit();
    }
    <span class="hljs-keyword">return</span>(<span class="hljs-built_in">this</span>.image);
}</pre></div></div>
            
        </li>
        
        
        <li id="section-9">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-9">&#x00a7;</a>
              </div>
              <h3 id="permanent-variables">Permanent variables</h3>

            </div>
            
        </li>
        
        
        <li id="section-10">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-10">&#x00a7;</a>
              </div>
              <p>The web worker maintains a semi-permanent storage space - the <strong>workstore</strong> - for some processing objects that are computationally expensive, for instance grids, matrix reference data objects, etc. The web worker maintains a record of when each of these processing objects was last accessed and will remove objects if they have not been accessed in the last three seconds.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>P.workstore = {},
P.workstoreLastAccessed = {};</pre></div></div>
            
        </li>
        
        
        <li id="section-11">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-11">&#x00a7;</a>
              </div>
              <h3 id="result-objects">Result objects</h3>

            </div>
            
        </li>
        
        
        <li id="section-12">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-12">&#x00a7;</a>
              </div>
              <p><code>createResultObject</code> - to make the following code easier to maintain, the web worker will create result objects for all source image data it receives, and for each action object output. These result objects contain four arrays - one for each color channle, and one for the alpha channel.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>P.createResultObject = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">len</span>) </span>{

    <span class="hljs-keyword">return</span> {
        <span class="hljs-attr">r</span>: <span class="hljs-keyword">new</span> <span class="hljs-built_in">Uint8ClampedArray</span>(len),
        <span class="hljs-attr">g</span>: <span class="hljs-keyword">new</span> <span class="hljs-built_in">Uint8ClampedArray</span>(len),
        <span class="hljs-attr">b</span>: <span class="hljs-keyword">new</span> <span class="hljs-built_in">Uint8ClampedArray</span>(len),
        <span class="hljs-attr">a</span>: <span class="hljs-keyword">new</span> <span class="hljs-built_in">Uint8ClampedArray</span>(len),
    };
};</pre></div></div>
            
        </li>
        
        
        <li id="section-13">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-13">&#x00a7;</a>
              </div>
              <p><code>copyOver</code> - copy the values from one results object to another</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>P.copyOver = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">f, t</span>) </span>{

    <span class="hljs-keyword">if</span> (f &amp;&amp; f.channels) f = f.channels;
    <span class="hljs-keyword">if</span> (t &amp;&amp; t.channels) t = t.channels;

    <span class="hljs-keyword">let</span> {<span class="hljs-attr">r</span>:fromR, <span class="hljs-attr">g</span>:fromG, <span class="hljs-attr">b</span>:fromB, <span class="hljs-attr">a</span>:fromA } = f;
    <span class="hljs-keyword">let</span> {<span class="hljs-attr">r</span>:toR, <span class="hljs-attr">g</span>:toG, <span class="hljs-attr">b</span>:toB, <span class="hljs-attr">a</span>:toA } = t;

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; fromR.length; i++) {

        toR[i] = fromR[i];
        toG[i] = fromG[i];
        toB[i] = fromB[i];
        toA[i] = fromA[i];
    }
};</pre></div></div>
            
        </li>
        
        
        <li id="section-14">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-14">&#x00a7;</a>
              </div>
              <p><code>unknit</code> - called at the start of each new message action chain. Creates and populates the <strong>source</strong> and <strong>work</strong> objects from the image data supplied in the message</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>P.unknit = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{

    <span class="hljs-keyword">let</span> { cache, image } = <span class="hljs-built_in">this</span>;

    <span class="hljs-keyword">let</span> { width, height, data } = image;

    <span class="hljs-keyword">let</span> len = <span class="hljs-built_in">Math</span>.floor(data.length / <span class="hljs-number">4</span>);

    <span class="hljs-keyword">let</span> source = <span class="hljs-built_in">this</span>.createResultObject(len);
    <span class="hljs-keyword">let</span> { <span class="hljs-attr">r</span>:sourceRed, <span class="hljs-attr">g</span>:sourceGreen, <span class="hljs-attr">b</span>:sourceBlue, <span class="hljs-attr">a</span>:sourceAlpha } = source;

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>, iz = data.length, counter = <span class="hljs-number">0</span>; i &lt; iz; i += <span class="hljs-number">4</span>) {

        sourceRed[counter] = data[i];
        sourceGreen[counter] = data[i + <span class="hljs-number">1</span>];
        sourceBlue[counter] = data[i + <span class="hljs-number">2</span>];
        sourceAlpha[counter] = data[i + <span class="hljs-number">3</span>];

        counter++;
    }

    <span class="hljs-keyword">let</span> work = <span class="hljs-built_in">this</span>.createResultObject(len);
    <span class="hljs-built_in">this</span>.copyOver(source, work);

    cache.source = {
        width,
        height,
        <span class="hljs-attr">channels</span>: source,
    };

    cache.work = {
        width,
        height,
        <span class="hljs-attr">channels</span>: work,
    };
};</pre></div></div>
            
        </li>
        
        
        <li id="section-15">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-15">&#x00a7;</a>
              </div>
              <p><code>knit</code> - called at the end of each message action chain. Recreates the message image data in the correct format so it can be used by the main thread</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>P.knit = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{

    <span class="hljs-keyword">let</span> { image, cache } = <span class="hljs-built_in">this</span>;

    <span class="hljs-keyword">let</span> { data } = image;
    <span class="hljs-keyword">let</span> { work } = cache;

    <span class="hljs-keyword">let</span> { <span class="hljs-attr">r</span>:workRed, <span class="hljs-attr">g</span>:workGreen, <span class="hljs-attr">b</span>:workBlue, <span class="hljs-attr">a</span>:workAlpha } = work.channels;

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>, iz = data.length, counter = <span class="hljs-number">0</span>; i &lt; iz; i += <span class="hljs-number">4</span>) {

        data[i] = workRed[counter];
        data[i + <span class="hljs-number">1</span>] = workGreen[counter];
        data[i + <span class="hljs-number">2</span>] = workBlue[counter];
        data[i + <span class="hljs-number">3</span>] = workAlpha[counter];

        counter++;
    }
};</pre></div></div>
            
        </li>
        
        
        <li id="section-16">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-16">&#x00a7;</a>
              </div>
              <h3 id="functions-invoked-by-a-range-of-different-action-functions">Functions invoked by a range of different action functions</h3>
<p><code>buildImageGrid</code> creates an Array of Arrays which contain the indexes of each pixel in the image channel Arrays</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>P.buildImageGrid = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">image</span>) </span>{

    <span class="hljs-keyword">let</span> { cache, workstore, workstoreLastAccessed } = <span class="hljs-built_in">this</span>;

    <span class="hljs-keyword">if</span> (!image) image = cache.source;

    <span class="hljs-keyword">let</span> { width, height } = image

    <span class="hljs-keyword">if</span> (width &amp;&amp; height) {

        <span class="hljs-keyword">let</span> name = <span class="hljs-string">`grid-<span class="hljs-subst">${width}</span>-<span class="hljs-subst">${height}</span>`</span>;
        <span class="hljs-keyword">if</span> (workstore[name]) {
            workstoreLastAccessed[name] = <span class="hljs-built_in">Date</span>.now();
            <span class="hljs-keyword">return</span> workstore[name];
        }

        <span class="hljs-keyword">let</span> grid = [],
            counter = <span class="hljs-number">0</span>;

        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> y = <span class="hljs-number">0</span>; y &lt; height; y++) {

            <span class="hljs-keyword">let</span> row = [];

            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> x = <span class="hljs-number">0</span>; x &lt; width; x++) {
                
                row.push(counter);
                counter++;
            }
            grid.push(row);
        }
        workstore[name] = grid;
        workstoreLastAccessed[name] = <span class="hljs-built_in">Date</span>.now();
        <span class="hljs-keyword">return</span> grid;
    }
    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
};</pre></div></div>
            
        </li>
        
        
        <li id="section-17">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-17">&#x00a7;</a>
              </div>
              <p><code>buildAlphaTileSets</code> - creates a record of which pixels belong to which tile - used for manipulating alpha channel values. Resulting object will be cached in the store</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>P.buildAlphaTileSets = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">tileWidth, tileHeight, gutterWidth, gutterHeight, offsetX, offsetY, areaAlphaLevels, image</span>) </span>{

    <span class="hljs-keyword">let</span> { cache, workstore, workstoreLastAccessed } = <span class="hljs-built_in">this</span>;

    <span class="hljs-keyword">if</span> (!image) image = cache.source;

    <span class="hljs-keyword">let</span> { <span class="hljs-attr">width</span>:iWidth, <span class="hljs-attr">height</span>:iHeight } = image;

    <span class="hljs-keyword">if</span> (iWidth &amp;&amp; iHeight) {

        tileWidth = (tileWidth.toFixed &amp;&amp; !<span class="hljs-built_in">isNaN</span>(tileWidth)) ? tileWidth : <span class="hljs-number">1</span>;
        tileHeight = (tileHeight.toFixed &amp;&amp; !<span class="hljs-built_in">isNaN</span>(tileHeight)) ? tileHeight : <span class="hljs-number">1</span>;
        gutterWidth = (gutterWidth.toFixed &amp;&amp; !<span class="hljs-built_in">isNaN</span>(gutterWidth)) ? gutterWidth : <span class="hljs-number">1</span>;
        gutterHeight = (gutterHeight.toFixed &amp;&amp; !<span class="hljs-built_in">isNaN</span>(gutterHeight)) ? gutterHeight : <span class="hljs-number">1</span>;
        offsetX = (offsetX.toFixed &amp;&amp; !<span class="hljs-built_in">isNaN</span>(offsetX)) ? offsetX : <span class="hljs-number">0</span>;
        offsetY = (offsetY.toFixed &amp;&amp; !<span class="hljs-built_in">isNaN</span>(offsetY)) ? offsetY : <span class="hljs-number">0</span>;

        <span class="hljs-keyword">if</span> (tileWidth &lt; <span class="hljs-number">1</span>) tileWidth = <span class="hljs-number">1</span>;
        <span class="hljs-keyword">if</span> (tileHeight &lt; <span class="hljs-number">1</span>) tileHeight = <span class="hljs-number">1</span>;
        <span class="hljs-keyword">if</span> (tileWidth + gutterWidth &gt;= iWidth) tileWidth = iWidth - gutterWidth - <span class="hljs-number">1</span>;
        <span class="hljs-keyword">if</span> (tileHeight + gutterHeight &gt;= iHeight) tileHeight = iHeight - gutterHeight - <span class="hljs-number">1</span>;

        <span class="hljs-keyword">if</span> (tileWidth &lt; <span class="hljs-number">1</span>) tileWidth = <span class="hljs-number">1</span>;
        <span class="hljs-keyword">if</span> (tileHeight &lt; <span class="hljs-number">1</span>) tileHeight = <span class="hljs-number">1</span>;
        <span class="hljs-keyword">if</span> (tileWidth + gutterWidth &gt;= iWidth) gutterWidth = iWidth - tileWidth - <span class="hljs-number">1</span>;
        <span class="hljs-keyword">if</span> (tileHeight + gutterHeight &gt;= iHeight) gutterHeight = iHeight - tileHeight - <span class="hljs-number">1</span>;

        <span class="hljs-keyword">let</span> aWidth = tileWidth + gutterWidth,
            aHeight = tileHeight + gutterHeight;

        <span class="hljs-keyword">if</span> (offsetX &lt; <span class="hljs-number">0</span>) offsetX = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">if</span> (offsetX &gt;= aWidth) offsetX = aWidth - <span class="hljs-number">1</span>;
        <span class="hljs-keyword">if</span> (offsetY &lt; <span class="hljs-number">0</span>) offsetY = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">if</span> (offsetY &gt;= aHeight) offsetY = aHeight - <span class="hljs-number">1</span>;

        <span class="hljs-keyword">let</span> name = <span class="hljs-string">`alphatileset-<span class="hljs-subst">${iWidth}</span>-<span class="hljs-subst">${iHeight}</span>-<span class="hljs-subst">${tileWidth}</span>-<span class="hljs-subst">${tileHeight}</span>-<span class="hljs-subst">${gutterWidth}</span>-<span class="hljs-subst">${gutterHeight}</span>-<span class="hljs-subst">${offsetX}</span>-<span class="hljs-subst">${offsetY}</span>`</span>;
        <span class="hljs-keyword">if</span> (workstore[name]) {
            workstoreLastAccessed[name] = <span class="hljs-built_in">Date</span>.now();
            <span class="hljs-keyword">return</span> workstore[name];
        }

        <span class="hljs-keyword">let</span> tiles = [],
            hold, i, iz, j, jz, x, xz, y, yz;

        <span class="hljs-keyword">for</span> (j = offsetY - aHeight, jz = iHeight; j &lt; jz; j += aHeight) {

            <span class="hljs-keyword">for</span> (i = offsetX - aWidth, iz = iWidth; i &lt; iz; i += aWidth) {

                hold = [];
                <span class="hljs-keyword">for</span> (y = j, yz = j + tileHeight; y &lt; yz; y++) {
                    <span class="hljs-keyword">if</span> (y &gt;= <span class="hljs-number">0</span> &amp;&amp; y &lt; iHeight) {
                        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> x = i, xz = i + tileWidth; x &lt; xz; x++) {
                            <span class="hljs-keyword">if</span> (x &gt;= <span class="hljs-number">0</span> &amp;&amp; x &lt; iWidth) hold.push((y * iWidth) + x);
                        }
                    }
                }
                tiles.push([].concat(hold));

                hold = [];
                <span class="hljs-keyword">for</span> (y =  j + tileHeight, yz = j + tileHeight + gutterHeight; y &lt; yz; y++) {
                    <span class="hljs-keyword">if</span> (y &gt;= <span class="hljs-number">0</span> &amp;&amp; y &lt; iHeight) {
                        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> x = i, xz = i + tileWidth; x &lt; xz; x++) {
                            <span class="hljs-keyword">if</span> (x &gt;= <span class="hljs-number">0</span> &amp;&amp; x &lt; iWidth) hold.push((y * iWidth) + x);
                        }
                    }
                }
                tiles.push([].concat(hold));

                hold = [];
                <span class="hljs-keyword">for</span> (y = j, yz = j + tileHeight; y &lt; yz; y++) {
                    <span class="hljs-keyword">if</span> (y &gt;= <span class="hljs-number">0</span> &amp;&amp; y &lt; iHeight) {
                        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> x = i + tileWidth, xz = i + tileWidth + gutterWidth; x &lt; xz; x++) {
                            <span class="hljs-keyword">if</span> (x &gt;= <span class="hljs-number">0</span> &amp;&amp; x &lt; iWidth) hold.push((y * iWidth) + x);
                        }
                    }
                }
                tiles.push([].concat(hold));

                hold = [];
                <span class="hljs-keyword">for</span> (y =  j + tileHeight, yz = j + tileHeight + gutterHeight; y &lt; yz; y++) {
                    <span class="hljs-keyword">if</span> (y &gt;= <span class="hljs-number">0</span> &amp;&amp; y &lt; iHeight) {
                        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> x = i + tileWidth, xz = i + tileWidth + gutterWidth; x &lt; xz; x++) {
                            <span class="hljs-keyword">if</span> (x &gt;= <span class="hljs-number">0</span> &amp;&amp; x &lt; iWidth) hold.push((y * iWidth) + x);
                        }
                    }
                }
                tiles.push([].concat(hold));
            }
        }
        workstore[name] = tiles;
        workstoreLastAccessed[name] = <span class="hljs-built_in">Date</span>.now();
        <span class="hljs-keyword">return</span> tiles;
    }
    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;

};</pre></div></div>
            
        </li>
        
        
        <li id="section-18">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-18">&#x00a7;</a>
              </div>
              <p><code>buildImageTileSets</code> - creates a record of which pixels belong to which tile - used for manipulating color channels values. Resulting object will be cached in the store</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>P.buildImageTileSets = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">tileWidth, tileHeight, offsetX, offsetY, image</span>) </span>{

    <span class="hljs-keyword">let</span> { cache, workstore, workstoreLastAccessed } = <span class="hljs-built_in">this</span>;

    <span class="hljs-keyword">if</span> (!image) image = cache.source;

    <span class="hljs-keyword">let</span> { <span class="hljs-attr">width</span>:iWidth, <span class="hljs-attr">height</span>:iHeight } = image;

    <span class="hljs-keyword">if</span> (iWidth &amp;&amp; iHeight) {

        tileWidth = (tileWidth.toFixed &amp;&amp; !<span class="hljs-built_in">isNaN</span>(tileWidth)) ? tileWidth : <span class="hljs-number">1</span>;
        tileHeight = (tileHeight.toFixed &amp;&amp; !<span class="hljs-built_in">isNaN</span>(tileHeight)) ? tileHeight : <span class="hljs-number">1</span>;
        offsetX = (offsetX.toFixed &amp;&amp; !<span class="hljs-built_in">isNaN</span>(offsetX)) ? offsetX : <span class="hljs-number">0</span>;
        offsetY = (offsetY.toFixed &amp;&amp; !<span class="hljs-built_in">isNaN</span>(offsetY)) ? offsetY : <span class="hljs-number">0</span>;

        <span class="hljs-keyword">if</span> (tileWidth &lt; <span class="hljs-number">1</span>) tileWidth = <span class="hljs-number">1</span>;
        <span class="hljs-keyword">if</span> (tileWidth &gt;= iWidth) tileWidth = iWidth - <span class="hljs-number">1</span>;
        <span class="hljs-keyword">if</span> (tileHeight &lt; <span class="hljs-number">1</span>) tileHeight = <span class="hljs-number">1</span>;
        <span class="hljs-keyword">if</span> (tileHeight &gt;= iHeight) tileHeight = iHeight - <span class="hljs-number">1</span>;
        <span class="hljs-keyword">if</span> (offsetX &lt; <span class="hljs-number">0</span>) offsetX = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">if</span> (offsetX &gt;= tileWidth) offsetX = tileWidth - <span class="hljs-number">1</span>;
        <span class="hljs-keyword">if</span> (offsetY &lt; <span class="hljs-number">0</span>) offsetY = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">if</span> (offsetY &gt;= tileHeight) offsetY = tileHeight - <span class="hljs-number">1</span>;

        <span class="hljs-keyword">let</span> name = <span class="hljs-string">`imagetileset-<span class="hljs-subst">${iWidth}</span>-<span class="hljs-subst">${iHeight}</span>-<span class="hljs-subst">${tileWidth}</span>-<span class="hljs-subst">${tileHeight}</span>-<span class="hljs-subst">${offsetX}</span>-<span class="hljs-subst">${offsetY}</span>`</span>;
        <span class="hljs-keyword">if</span> (workstore[name]) {
            workstoreLastAccessed[name] = <span class="hljs-built_in">Date</span>.now();
            <span class="hljs-keyword">return</span> workstore[name];
        }

        <span class="hljs-keyword">let</span> tiles = [];

        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = offsetY - tileHeight, jz = iHeight; j &lt; jz; j += tileHeight) {

            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = offsetX - tileWidth, iz = iWidth; i &lt; iz; i += tileWidth) {

                <span class="hljs-keyword">let</span> hold = [];
                
                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> y = j, yz = j + tileHeight; y &lt; yz; y++) {

                    <span class="hljs-keyword">if</span> (y &gt;= <span class="hljs-number">0</span> &amp;&amp; y &lt; iHeight) {

                        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> x = i, xz = i + tileWidth; x &lt; xz; x++) {

                            <span class="hljs-keyword">if</span> (x &gt;= <span class="hljs-number">0</span> &amp;&amp; x &lt; iWidth) hold.push((y * iWidth) + x);
                        }
                    }
                }
                <span class="hljs-keyword">if</span> (hold.length) tiles.push(hold);
            }
        }
        workstore[name] = tiles;
        workstoreLastAccessed[name] = <span class="hljs-built_in">Date</span>.now();
        <span class="hljs-keyword">return</span> tiles;
    }
    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
};</pre></div></div>
            
        </li>
        
        
        <li id="section-19">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-19">&#x00a7;</a>
              </div>
              <p><code>buildHorizontalBlur</code> - creates an Array of Arrays detailing which pixels contribute to the horizontal part of each pixel’s blur calculation. Resulting object will be cached in the store</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>P.buildHorizontalBlur = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">grid, radius</span>) </span>{

    <span class="hljs-keyword">let</span> { workstore, workstoreLastAccessed } = <span class="hljs-built_in">this</span>;

    <span class="hljs-keyword">if</span> (!radius || !radius.toFixed || <span class="hljs-built_in">isNaN</span>(radius)) radius = <span class="hljs-number">0</span>;

    <span class="hljs-keyword">let</span> gridHeight = grid.length,
        gridWidth = grid[<span class="hljs-number">0</span>].length;

    <span class="hljs-keyword">let</span> name = <span class="hljs-string">`blur-h-<span class="hljs-subst">${gridWidth}</span>-<span class="hljs-subst">${gridHeight}</span>-<span class="hljs-subst">${radius}</span>`</span>;
    <span class="hljs-keyword">if</span> (workstore[name]) {
        workstoreLastAccessed[name] = <span class="hljs-built_in">Date</span>.now();
        <span class="hljs-keyword">return</span> workstore[name];
    }

    <span class="hljs-keyword">let</span> horizontalBlur = [],
        cell;

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> y = <span class="hljs-number">0</span>; y &lt; gridHeight; y++) {

        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> x = <span class="hljs-number">0</span>; x &lt; gridWidth; x++) {

            <span class="hljs-keyword">let</span> cellsToProcess = [];

            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> c = x - radius, cz = x + radius + <span class="hljs-number">1</span>; c &lt; cz; c++) {

                <span class="hljs-keyword">if</span> (c &gt;= <span class="hljs-number">0</span> &amp;&amp; c &lt; gridWidth) cellsToProcess.push(grid[y][c]);
            }
            horizontalBlur[(y * gridWidth) + x] = cellsToProcess;
        }
    }
    workstore[name] = horizontalBlur;
    workstoreLastAccessed[name] = <span class="hljs-built_in">Date</span>.now();
    <span class="hljs-keyword">return</span> horizontalBlur;
};</pre></div></div>
            
        </li>
        
        
        <li id="section-20">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-20">&#x00a7;</a>
              </div>
              <p><code>buildVerticalBlur</code> - creates an Array of Arrays detailing which pixels contribute to the vertical part of each pixel’s blur calculation. Resulting object will be cached in the store</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>P.buildVerticalBlur = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">grid, radius</span>) </span>{

    <span class="hljs-keyword">let</span> { workstore, workstoreLastAccessed } = <span class="hljs-built_in">this</span>;

    <span class="hljs-keyword">if</span> (!radius || !radius.toFixed || <span class="hljs-built_in">isNaN</span>(radius)) radius = <span class="hljs-number">0</span>;

    <span class="hljs-keyword">let</span> gridHeight = grid.length,
        gridWidth = grid[<span class="hljs-number">0</span>].length;

    <span class="hljs-keyword">let</span> name = <span class="hljs-string">`blur-v-<span class="hljs-subst">${gridWidth}</span>-<span class="hljs-subst">${gridHeight}</span>-<span class="hljs-subst">${radius}</span>`</span>;
    <span class="hljs-keyword">if</span> (workstore[name]) {
        workstoreLastAccessed[name] = <span class="hljs-built_in">Date</span>.now();
        <span class="hljs-keyword">return</span> workstore[name];
    }

    <span class="hljs-keyword">let</span> verticalBlur = [],
        cell;

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> x = <span class="hljs-number">0</span>; x &lt; gridWidth; x++) {

        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> y = <span class="hljs-number">0</span>; y &lt; gridHeight; y++) {

            <span class="hljs-keyword">let</span> cellsToProcess = [];

            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> c = y - radius, cz = y + radius + <span class="hljs-number">1</span>; c &lt; cz; c++) {

                <span class="hljs-keyword">if</span> (c &gt;= <span class="hljs-number">0</span> &amp;&amp; c &lt; gridHeight) cellsToProcess.push(grid[c][x]);
            }
            verticalBlur[(y * gridWidth) + x] = cellsToProcess;
        }
    }
    workstore[name] = verticalBlur;
    workstoreLastAccessed[name] = <span class="hljs-built_in">Date</span>.now();
    <span class="hljs-keyword">return</span> verticalBlur;
};</pre></div></div>
            
        </li>
        
        
        <li id="section-21">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-21">&#x00a7;</a>
              </div>
              <p><code>buildMatrixGrid</code> - creates an Array of Arrays detailing which pixels contribute to each pixel’s matrix calculation. Resulting object will be cached in the store</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>P.buildMatrixGrid = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">mWidth, mHeight, mX, mY, alpha, image</span>) </span>{

    <span class="hljs-keyword">let</span> { cache, workstore, workstoreLastAccessed } = <span class="hljs-built_in">this</span>;

    <span class="hljs-keyword">if</span> (!image) image = cache.source;

    <span class="hljs-keyword">let</span> { <span class="hljs-attr">width</span>:iWidth, <span class="hljs-attr">height</span>:iHeight, channels } = image;

    <span class="hljs-keyword">if</span> (mWidth == <span class="hljs-literal">null</span> || mWidth &lt; <span class="hljs-number">1</span>) mWidth = <span class="hljs-number">1</span>;
    <span class="hljs-keyword">if</span> (mHeight == <span class="hljs-literal">null</span> || mHeight &lt; <span class="hljs-number">1</span>) mHeight = <span class="hljs-number">1</span>;

    <span class="hljs-keyword">if</span> (mX == <span class="hljs-literal">null</span> || mX &lt; <span class="hljs-number">0</span>) mX = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (mX &gt;= mWidth) mX = mWidth - <span class="hljs-number">1</span>;

    <span class="hljs-keyword">if</span> (mY == <span class="hljs-literal">null</span> || mY &lt; <span class="hljs-number">0</span>) mY = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (mY &gt;= mHeight) mY = mHeight - <span class="hljs-number">1</span>;

    <span class="hljs-keyword">let</span> name = <span class="hljs-string">`matrix-<span class="hljs-subst">${iWidth}</span>-<span class="hljs-subst">${iHeight}</span>-<span class="hljs-subst">${mWidth}</span>-<span class="hljs-subst">${mHeight}</span>-<span class="hljs-subst">${mX}</span>-<span class="hljs-subst">${mY}</span>`</span>;
    <span class="hljs-keyword">if</span> (workstore[name]) {
        workstoreLastAccessed[name] = <span class="hljs-built_in">Date</span>.now();
        <span class="hljs-keyword">return</span> workstore[name];
    }

    <span class="hljs-keyword">let</span> dataLength = channels.r.length,
        x, xz, y, yz, i, iz,
        cellsTemplate = [],
        grid = [];

    <span class="hljs-keyword">for</span> (y = -mY, yz = mHeight - mY; y &lt; yz; y++) {

        <span class="hljs-keyword">for</span> (x = -mX, xz = mWidth - mX; x &lt; xz; x++) {

            cellsTemplate.push((y * iWidth) + x);
        }
    }

    <span class="hljs-keyword">for</span> (y = <span class="hljs-number">0</span>; y &lt; iHeight; y++) {

        <span class="hljs-keyword">for</span> (x = <span class="hljs-number">0</span>; x &lt; iWidth; x++) {
            
            <span class="hljs-keyword">let</span> pos = (y * iWidth) + x;
            <span class="hljs-keyword">let</span> cell = [];

            <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>, iz = cellsTemplate.length; i &lt; iz; i++) {

                <span class="hljs-keyword">let</span> val = pos + cellsTemplate[i];

                <span class="hljs-keyword">if</span> (val &lt; <span class="hljs-number">0</span>) val += dataLength;
                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (val &gt;= dataLength) val -= dataLength;

                cell.push(val);
            }
            grid.push(cell);
        }
    }
    workstore[name] = grid;
    workstoreLastAccessed[name] = <span class="hljs-built_in">Date</span>.now();
    <span class="hljs-keyword">return</span> grid;
};</pre></div></div>
            
        </li>
        
        
        <li id="section-22">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-22">&#x00a7;</a>
              </div>
              <p><code>checkChannelLevelsParameters</code> - divide each channel into discrete sequences of pixels</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>P.checkChannelLevelsParameters = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">f</span>) </span>{

    <span class="hljs-keyword">const</span> doCheck = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">v, isHigh = <span class="hljs-literal">false</span></span>) </span>{

        <span class="hljs-keyword">if</span> (v.toFixed) {
            <span class="hljs-keyword">if</span> (v &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> [[<span class="hljs-number">0</span>, <span class="hljs-number">255</span>, <span class="hljs-number">0</span>]];
            <span class="hljs-keyword">if</span> (v &gt; <span class="hljs-number">255</span>) <span class="hljs-keyword">return</span> [[<span class="hljs-number">0</span>, <span class="hljs-number">255</span>, <span class="hljs-number">255</span>]];
            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isNaN</span>(v)) <span class="hljs-keyword">return</span> (isHigh) ? [[<span class="hljs-number">0</span>, <span class="hljs-number">255</span>, <span class="hljs-number">255</span>]] : [[<span class="hljs-number">0</span>, <span class="hljs-number">255</span>, <span class="hljs-number">0</span>]];
            <span class="hljs-keyword">return</span> [[<span class="hljs-number">0</span>, <span class="hljs-number">255</span>, v]];
        }

        <span class="hljs-keyword">if</span> (v.substring) {
            v = v.split(<span class="hljs-string">&#x27;,&#x27;</span>);
        }

        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Array</span>.isArray(v)) {

            <span class="hljs-keyword">if</span> (!v.length) <span class="hljs-keyword">return</span> v;
            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Array</span>.isArray(v[<span class="hljs-number">0</span>])) <span class="hljs-keyword">return</span> v;

            v = v.map(<span class="hljs-function"><span class="hljs-params">s</span> =&gt;</span> <span class="hljs-built_in">parseInt</span>(s, <span class="hljs-number">10</span>));
            v.sort(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a - b);

            <span class="hljs-keyword">if</span> (v.length == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> [[<span class="hljs-number">0</span>, <span class="hljs-number">255</span>, v[<span class="hljs-number">0</span>]]];

            <span class="hljs-keyword">let</span> res = [],
                starts, ends;

            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>, iz = v.length; i &lt; iz; i++) {

                starts = <span class="hljs-number">0</span>;
                ends = <span class="hljs-number">255</span>;
                <span class="hljs-keyword">if</span> (i != <span class="hljs-number">0</span>) starts = <span class="hljs-built_in">Math</span>.ceil(v[i - <span class="hljs-number">1</span>] + ((v[i] - v[i - <span class="hljs-number">1</span>]) / <span class="hljs-number">2</span>));
                <span class="hljs-keyword">if</span> (i != iz - <span class="hljs-number">1</span>) ends = <span class="hljs-built_in">Math</span>.floor(v[i] + ((v[i + <span class="hljs-number">1</span>] - v[i]) / <span class="hljs-number">2</span>));

                res.push([starts, ends, v[i]]);
            }
            <span class="hljs-keyword">return</span> res;
        }
        <span class="hljs-keyword">return</span> (isHigh) ? [[<span class="hljs-number">0</span>, <span class="hljs-number">255</span>, <span class="hljs-number">255</span>]] : [[<span class="hljs-number">0</span>, <span class="hljs-number">255</span>, <span class="hljs-number">0</span>]];
    }
    f.red = doCheck(f.red);
    f.green = doCheck(f.green);
    f.blue = doCheck(f.blue);
    f.alpha = doCheck(f.alpha, <span class="hljs-literal">true</span>);
};</pre></div></div>
            
        </li>
        
        
        <li id="section-23">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-23">&#x00a7;</a>
              </div>
              <p><code>cacheOutput</code> - insert an action function’s output into the worker’s cache</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>P.cacheOutput = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">name, obj, caller</span>) </span>{

    cache[name] = obj;
};</pre></div></div>
            
        </li>
        
        
        <li id="section-24">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-24">&#x00a7;</a>
              </div>
              <p><code>getInputAndOutputDimensions</code> - determine, and return, the dimensions (width, height) for the appropriate results object for the lineIn, lineMix and lineOut values supplied to each action function when it gets invoked</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>P.getInputAndOutputDimensions = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">requirements</span>) </span>{

    <span class="hljs-keyword">let</span> { cache } = <span class="hljs-built_in">this</span>;

    <span class="hljs-keyword">let</span> data = cache.source,
        results = [];

    <span class="hljs-keyword">if</span> (requirements.lineIn &amp;&amp; requirements.lineIn != <span class="hljs-string">&#x27;source&#x27;</span> &amp;&amp; requirements.lineIn != <span class="hljs-string">&#x27;source-alpha&#x27;</span> &amp;&amp; cache[requirements.lineIn]) {

        data = cache[requirements.lineIn];
    }
    results.push(data.width, data.height);

    <span class="hljs-keyword">if</span> (requirements.lineOut &amp;&amp; cache[requirements.lineOut]) {

        data = cache[requirements.lineOut];
    }
    results.push(data.width, data.height);

    data = cache.source;

    <span class="hljs-keyword">if</span> (requirements.lineMix &amp;&amp; requirements.lineMix != <span class="hljs-string">&#x27;source&#x27;</span> &amp;&amp; requirements.lineMix != <span class="hljs-string">&#x27;source-alpha&#x27;</span> &amp;&amp; cache[requirements.lineMix]) {

        data = cache[requirements.lineMix];
    }
    results.push(data.width, data.height);

    <span class="hljs-keyword">return</span> results;
};</pre></div></div>
            
        </li>
        
        
        <li id="section-25">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-25">&#x00a7;</a>
              </div>
              <p><code>getInputAndOutputChannels</code> - determine, and return, the appropriate results object for the lineIn, lineMix and lineOut values supplied to each action function when it gets invoked</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>P.getInputAndOutputChannels = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">requirements</span>) </span>{

    <span class="hljs-keyword">let</span> { cache } = <span class="hljs-built_in">this</span>;

    <span class="hljs-keyword">let</span> lineIn = cache.work.channels;
    <span class="hljs-keyword">let</span> len = lineIn.r.length;
    <span class="hljs-keyword">let</span> data = cache.source;

    <span class="hljs-keyword">if</span> (requirements.lineIn) {

        <span class="hljs-keyword">if</span> (requirements.lineIn == <span class="hljs-string">&#x27;source&#x27;</span>) lineIn = data.channels;
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (requirements.lineIn == <span class="hljs-string">&#x27;source-alpha&#x27;</span>) {

            lineIn = <span class="hljs-built_in">this</span>.createResultObject(len);

            <span class="hljs-keyword">let</span> destAlpha = lineIn.a,
                sourceAlpha = data.channels.a;

            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) {

                destAlpha[i] = sourceAlpha[i];
            }
        }
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cache[requirements.lineIn]) {

            data = cache[requirements.lineIn];
            lineIn = data.channels;
        }
    }

    <span class="hljs-keyword">let</span> lineMix = <span class="hljs-literal">false</span>;

    <span class="hljs-keyword">if</span> (requirements.lineMix) {

        <span class="hljs-keyword">if</span> (requirements.lineMix == <span class="hljs-string">&#x27;source&#x27;</span>) lineMix = cache.source.channels;
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (requirements.lineMix == <span class="hljs-string">&#x27;source-alpha&#x27;</span>) {

            lineMix = <span class="hljs-built_in">this</span>.createResultObject(len);

            <span class="hljs-keyword">let</span> destAlpha = lineMix.a,
                sourceAlpha = cache.source.channels.a;

            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) {

                destAlpha[i] = sourceAlpha[i];
            }
        }
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cache[requirements.lineMix]) lineMix = cache[requirements.lineMix].channels;
    }

    <span class="hljs-keyword">let</span> lineOut;

    <span class="hljs-keyword">if</span> (requirements.lineOut) {

        <span class="hljs-keyword">if</span> (cache[requirements.lineOut]) lineOut = cache[requirements.lineOut].channels;
        <span class="hljs-keyword">else</span> {

            lineOut = <span class="hljs-built_in">this</span>.createResultObject(len);
            cache[requirements.lineOut] = {
                <span class="hljs-attr">width</span>: data.width,
                <span class="hljs-attr">height</span>: data.height,
                <span class="hljs-attr">channels</span>: lineOut,
            };
        }
    }
    <span class="hljs-keyword">else</span> lineOut = <span class="hljs-built_in">this</span>.createResultObject(len);

    <span class="hljs-keyword">return</span> [lineIn, lineOut, lineMix];
};</pre></div></div>
            
        </li>
        
        
        <li id="section-26">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-26">&#x00a7;</a>
              </div>
              <p><code>processResults</code> - at the conclusion of each action function, combine the results of the function’s manipulations back into the data supplied for manipulation, in line with the value of the action object’s <code>opacity</code> attribute</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>P.processResults = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">store, incoming, ratio</span>) </span>{

    <span class="hljs-keyword">let</span> sR = store.r,
        sG = store.g,
        sB = store.b,
        sA = store.a;

    <span class="hljs-keyword">let</span> iR = incoming.r,
        iG = incoming.g,
        iB = incoming.b,
        iA = incoming.a;

    <span class="hljs-keyword">if</span> (ratio === <span class="hljs-number">1</span>) <span class="hljs-built_in">this</span>.copyOver(incoming, store);
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ratio &gt; <span class="hljs-number">0</span>) {

        <span class="hljs-keyword">let</span> antiRatio = <span class="hljs-number">1</span> - ratio;

        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>, iz = sR.length; i &lt; iz; i++) {

            sR[i] = <span class="hljs-built_in">Math</span>.floor((sR[i] * antiRatio) + (iR[i] * ratio));
            sG[i] = <span class="hljs-built_in">Math</span>.floor((sG[i] * antiRatio) + (iG[i] * ratio));
            sB[i] = <span class="hljs-built_in">Math</span>.floor((sB[i] * antiRatio) + (iB[i] * ratio));
            sA[i] = <span class="hljs-built_in">Math</span>.floor((sA[i] * antiRatio) + (iA[i] * ratio));
        }
    }
};</pre></div></div>
            
        </li>
        
        
        <li id="section-27">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-27">&#x00a7;</a>
              </div>
              <p><code>getHSLfromRGB</code> - convert an RGB format color into an HSL format color</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>P.getHSLfromRGB = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">dr, dg, db</span>) </span>{

    <span class="hljs-keyword">let</span> minColor = <span class="hljs-built_in">Math</span>.min(dr, dg, db),
        maxColor = <span class="hljs-built_in">Math</span>.max(dr, dg, db);

    <span class="hljs-keyword">let</span> lum = (minColor + maxColor) / <span class="hljs-number">2</span>;

    <span class="hljs-keyword">let</span> sat = <span class="hljs-number">0</span>;

    <span class="hljs-keyword">if</span> (minColor !== maxColor) {

        <span class="hljs-keyword">if</span> (lum &lt;= <span class="hljs-number">0.5</span>) sat = (maxColor - minColor) / (maxColor + minColor);
        <span class="hljs-keyword">else</span> sat = (maxColor - minColor) / (<span class="hljs-number">2</span> - maxColor - minColor);
    }

    <span class="hljs-keyword">let</span> hue = <span class="hljs-number">0</span>;

    <span class="hljs-keyword">if</span> (maxColor === dr) hue = (dg - db) / (maxColor - minColor);
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (maxColor === dg) hue = <span class="hljs-number">2</span> + ((db - dr) / (maxColor - minColor));
    <span class="hljs-keyword">else</span> hue = <span class="hljs-number">4</span> + ((dr - dg) / (maxColor - minColor));

    hue *= <span class="hljs-number">60</span>;

    <span class="hljs-keyword">if</span> (hue &lt; <span class="hljs-number">0</span>) hue += <span class="hljs-number">360</span>;

    <span class="hljs-keyword">return</span> [hue, sat, lum];
};</pre></div></div>
            
        </li>
        
        
        <li id="section-28">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-28">&#x00a7;</a>
              </div>
              <p><code>getRGBfromHSL</code> - convert an HSL format color into an RGB format color</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>P.getRGBfromHSL = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">h, s, l</span>) </span>{

    <span class="hljs-keyword">if</span> (!s) {

        <span class="hljs-keyword">let</span> gray = <span class="hljs-built_in">Math</span>.floor(l * <span class="hljs-number">255</span>);
        <span class="hljs-keyword">return</span> [gray, gray, gray];
    }

    <span class="hljs-keyword">let</span> tempLum1 = (l &lt; <span class="hljs-number">0.5</span>) ? l * (s + <span class="hljs-number">1</span>) : l + s - (l * s),
        tempLum2 = (<span class="hljs-number">2</span> * l) - tempLum1;

    <span class="hljs-keyword">const</span> calculator = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">t, l1, l2</span>) </span>{

        <span class="hljs-keyword">if</span> (t * <span class="hljs-number">6</span> &lt; <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> l2 + ((l1 - l2) * <span class="hljs-number">6</span> * t);
        <span class="hljs-keyword">if</span> (t * <span class="hljs-number">2</span> &lt; <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> l1;
        <span class="hljs-keyword">if</span> (t * <span class="hljs-number">2</span> &lt; <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> l2 + ((l1 - l2) * <span class="hljs-number">6</span> * (t * <span class="hljs-number">0.666</span>));
        <span class="hljs-keyword">return</span> l2;
    };

    h /= <span class="hljs-number">360</span>;

    <span class="hljs-keyword">let</span> tr = h + <span class="hljs-number">0.333</span>,
        tg = h,
        tb = h - <span class="hljs-number">0.333</span>;

    <span class="hljs-keyword">if</span> (tr &lt; <span class="hljs-number">0</span>) tr += <span class="hljs-number">1</span>;
    <span class="hljs-keyword">if</span> (tr &gt; <span class="hljs-number">1</span>) tr -= <span class="hljs-number">1</span>;
    <span class="hljs-keyword">if</span> (tg &lt; <span class="hljs-number">0</span>) tg += <span class="hljs-number">1</span>;
    <span class="hljs-keyword">if</span> (tg &gt; <span class="hljs-number">1</span>) tg -= <span class="hljs-number">1</span>;
    <span class="hljs-keyword">if</span> (tb &lt; <span class="hljs-number">0</span>) tb += <span class="hljs-number">1</span>;
    <span class="hljs-keyword">if</span> (tb &gt; <span class="hljs-number">1</span>) tb -= <span class="hljs-number">1</span>;

    <span class="hljs-keyword">let</span> r = calculator(tr, tempLum1, tempLum2) * <span class="hljs-number">255</span>,
        g = calculator(tg, tempLum1, tempLum2) * <span class="hljs-number">255</span>,
        b = calculator(tb, tempLum1, tempLum2) * <span class="hljs-number">255</span>;

    <span class="hljs-keyword">return</span> [r, g, b];
};</pre></div></div>
            
        </li>
        
        
        <li id="section-29">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-29">&#x00a7;</a>
              </div>
              <h2 id="filter-action-functions">Filter action functions</h2>
<p>Each function is held in the <code>theBigActionsObject</code> object, for convenience</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>P.theBigActionsObject = {</pre></div></div>
            
        </li>
        
        
        <li id="section-30">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-30">&#x00a7;</a>
              </div>
              <p><strong>alpha-to-channels</strong> - Copies the alpha channel value over to the selected value or, alternatively, sets that channels value to zero, or leaves the channel’s value unchanged. Setting the appropriate “includeChannel” flags will copy the alpha channel value to that channel; when that flag is false, setting the appropriate “excludeChannel” flag will set that channel’s value to zero.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-string">&#x27;alpha-to-channels&#x27;</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">requirements</span>) </span>{

        <span class="hljs-keyword">let</span> [input, output] = <span class="hljs-built_in">this</span>.getInputAndOutputChannels(requirements);

        <span class="hljs-keyword">let</span> len = input.r.length;

        <span class="hljs-keyword">let</span> {opacity, includeRed, includeGreen, includeBlue, excludeRed, excludeGreen, excludeBlue, lineOut} = requirements;

        <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> == opacity) opacity = <span class="hljs-number">1</span>;
        <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> == includeRed) includeRed = <span class="hljs-literal">true</span>;
        <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> == includeGreen) includeGreen = <span class="hljs-literal">true</span>;
        <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> == includeBlue) includeBlue = <span class="hljs-literal">true</span>;
        <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> == excludeRed) excludeRed = <span class="hljs-literal">true</span>;
        <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> == excludeGreen) excludeGreen = <span class="hljs-literal">true</span>;
        <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> == excludeBlue) excludeBlue = <span class="hljs-literal">true</span>;

        <span class="hljs-keyword">const</span> {<span class="hljs-attr">r</span>:inR, <span class="hljs-attr">g</span>:inG, <span class="hljs-attr">b</span>:inB, <span class="hljs-attr">a</span>:inA} = input;
        <span class="hljs-keyword">const</span> {<span class="hljs-attr">r</span>:outR, <span class="hljs-attr">g</span>:outG, <span class="hljs-attr">b</span>:outB, <span class="hljs-attr">a</span>:outA} = output;

        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) {

            outR[i] = (includeRed) ? inA[i] : ((excludeRed) ? <span class="hljs-number">0</span> : inR[i]);
            outG[i] = (includeGreen) ? inA[i] : ((excludeGreen) ? <span class="hljs-number">0</span> : inG[i]);
            outB[i] = (includeBlue) ? inA[i] : ((excludeBlue) ? <span class="hljs-number">0</span> : inB[i]);
        }
        outA.fill(<span class="hljs-number">255</span>, <span class="hljs-number">0</span>, outA.length - <span class="hljs-number">1</span>);

        <span class="hljs-keyword">let</span> work = <span class="hljs-built_in">this</span>.cache.work.channels;
        <span class="hljs-keyword">if</span> (lineOut) <span class="hljs-built_in">this</span>.processResults(output, work, <span class="hljs-number">1</span> - opacity);
        <span class="hljs-keyword">else</span> <span class="hljs-built_in">this</span>.processResults(work, output, opacity);
    },</pre></div></div>
            
        </li>
        
        
        <li id="section-31">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-31">&#x00a7;</a>
              </div>
              <p><strong>area-alpha</strong> - Places a tile schema across the input, quarters each tile and then sets the alpha channels of the pixels in selected quarters of each tile to zero. Can be used to create horizontal or vertical bars, or chequerboard effects.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-string">&#x27;area-alpha&#x27;</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">requirements</span>) </span>{

        <span class="hljs-keyword">let</span> [input, output] = <span class="hljs-built_in">this</span>.getInputAndOutputChannels(requirements);

        <span class="hljs-keyword">let</span> len = input.r.length;

        <span class="hljs-keyword">let</span> {opacity, tileWidth, tileHeight, offsetX, offsetY, gutterWidth, gutterHeight, areaAlphaLevels, lineOut} = requirements;

        <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> == opacity) opacity = <span class="hljs-number">1</span>;
        <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> == tileWidth) tileWidth = <span class="hljs-number">1</span>;
        <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> == tileHeight) tileHeight = <span class="hljs-number">1</span>;
        <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> == offsetX) offsetX = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> == offsetY) offsetY = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> == gutterWidth) gutterWidth = <span class="hljs-number">1</span>;
        <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> == gutterHeight) gutterHeight = <span class="hljs-number">1</span>;
        <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> == areaAlphaLevels) areaAlphaLevels = [<span class="hljs-number">255</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>];

        <span class="hljs-keyword">let</span> tiles = <span class="hljs-built_in">this</span>.buildAlphaTileSets(tileWidth, tileHeight, gutterWidth, gutterHeight, offsetX, offsetY, areaAlphaLevels);

        <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">Array</span>.isArray(areaAlphaLevels)) areaAlphaLevels = [<span class="hljs-number">255</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>];

        <span class="hljs-keyword">const</span> {<span class="hljs-attr">r</span>:inR, <span class="hljs-attr">g</span>:inG, <span class="hljs-attr">b</span>:inB, <span class="hljs-attr">a</span>:inA} = input;
        <span class="hljs-keyword">const</span> {<span class="hljs-attr">r</span>:outR, <span class="hljs-attr">g</span>:outG, <span class="hljs-attr">b</span>:outB, <span class="hljs-attr">a</span>:outA} = output;

        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) {
            outR[i] = inR[i];
            outG[i] = inG[i];
            outB[i] = inB[i];
        }
        tiles.forEach(<span class="hljs-function">(<span class="hljs-params">t, index</span>) =&gt;</span> {

            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>, jz = t.length; j &lt; jz; j++) {

                <span class="hljs-keyword">if</span> (inA[t[j]]) outA[t[j]] = areaAlphaLevels[index % <span class="hljs-number">4</span>];
            }
        });

        <span class="hljs-keyword">let</span> work = <span class="hljs-built_in">this</span>.cache.work.channels;
        <span class="hljs-keyword">if</span> (lineOut) <span class="hljs-built_in">this</span>.processResults(output, work, <span class="hljs-number">1</span> - opacity);
        <span class="hljs-keyword">else</span> <span class="hljs-built_in">this</span>.processResults(work, output, opacity);
    },</pre></div></div>
            
        </li>
        
        
        <li id="section-32">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-32">&#x00a7;</a>
              </div>
              <p><strong>average-channels</strong> - Calculates an average value from each pixel’s included channels and applies that value to all channels that have not been specifically excluded; excluded channels have their values set to 0.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-string">&#x27;average-channels&#x27;</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">requirements</span>) </span>{

        <span class="hljs-keyword">let</span> [input, output] = <span class="hljs-built_in">this</span>.getInputAndOutputChannels(requirements);

        <span class="hljs-keyword">let</span> len = input.r.length;

        <span class="hljs-keyword">let</span> {opacity, includeRed, includeGreen, includeBlue, excludeRed, excludeGreen, excludeBlue, lineOut} = requirements;

        <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> == opacity) opacity = <span class="hljs-number">1</span>;
        <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> == includeRed) includeRed = <span class="hljs-literal">true</span>;
        <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> == includeGreen) includeGreen = <span class="hljs-literal">true</span>;
        <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> == includeBlue) includeBlue = <span class="hljs-literal">true</span>;
        <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> == excludeRed) excludeRed = <span class="hljs-literal">false</span>;
        <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> == excludeGreen) excludeGreen = <span class="hljs-literal">false</span>;
        <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> == excludeBlue) excludeBlue = <span class="hljs-literal">false</span>;

        <span class="hljs-keyword">let</span> divisor = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">if</span> (includeRed) divisor++;
        <span class="hljs-keyword">if</span> (includeGreen) divisor++;
        <span class="hljs-keyword">if</span> (includeBlue) divisor++;

        <span class="hljs-keyword">const</span> {<span class="hljs-attr">r</span>:inR, <span class="hljs-attr">g</span>:inG, <span class="hljs-attr">b</span>:inB, <span class="hljs-attr">a</span>:inA} = input;
        <span class="hljs-keyword">const</span> {<span class="hljs-attr">r</span>:outR, <span class="hljs-attr">g</span>:outG, <span class="hljs-attr">b</span>:outB, <span class="hljs-attr">a</span>:outA} = output;

        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) {

            <span class="hljs-keyword">if</span> (inA[i]) {

                <span class="hljs-keyword">if</span> (divisor) {

                    <span class="hljs-keyword">let</span> avg = <span class="hljs-number">0</span>;

                    <span class="hljs-keyword">if</span> (includeRed) avg += inR[i];
                    <span class="hljs-keyword">if</span> (includeGreen) avg += inG[i];
                    <span class="hljs-keyword">if</span> (includeBlue) avg += inB[i];

                    avg = <span class="hljs-built_in">Math</span>.floor(avg / divisor);

                    outR[i] = (excludeRed) ? <span class="hljs-number">0</span> : avg;
                    outG[i] = (excludeGreen) ? <span class="hljs-number">0</span> : avg;
                    outB[i] = (excludeBlue) ? <span class="hljs-number">0</span> : avg;
                    outA[i] = inA[i];
                }
                <span class="hljs-keyword">else</span> {
    
                    outR[i] = (excludeRed) ? <span class="hljs-number">0</span> : inR[i];
                    outG[i] = (excludeGreen) ? <span class="hljs-number">0</span> : inG[i];
                    outB[i] = (excludeBlue) ? <span class="hljs-number">0</span> : inB[i];
                    outA[i] = inA[i];
                }
            }
            <span class="hljs-keyword">else</span> {

                outR[i] = inR[i];
                outG[i] = inG[i];
                outB[i] = inB[i];
                outA[i] = inA[i];
            }
        }

        <span class="hljs-keyword">let</span> work = <span class="hljs-built_in">this</span>.cache.work.channels;
        <span class="hljs-keyword">if</span> (lineOut) <span class="hljs-built_in">this</span>.processResults(output, work, <span class="hljs-number">1</span> - opacity);
        <span class="hljs-keyword">else</span> <span class="hljs-built_in">this</span>.processResults(work, output, opacity);
    },</pre></div></div>
            
        </li>
        
        
        <li id="section-33">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-33">&#x00a7;</a>
              </div>
              <p><strong>binary</strong> - Set the channel to either 0 or 255, depending on whether the channel value is below or above a given level. Level values are set using the “red”, “green”, “blue” and “alpha” arguments. Setting these values to 0 disables the action for that channel.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-string">&#x27;binary&#x27;</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">requirements</span>) </span>{

        <span class="hljs-keyword">let</span> [input, output] = <span class="hljs-built_in">this</span>.getInputAndOutputChannels(requirements);

        <span class="hljs-keyword">let</span> len = input.r.length;

        <span class="hljs-keyword">let</span> {opacity, red, green, blue, alpha, lineOut} = requirements;

        <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> == opacity) opacity = <span class="hljs-number">1</span>;
        <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> == red) red = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> == green) green = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> == blue) blue = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> == alpha) alpha = <span class="hljs-number">0</span>;

        <span class="hljs-keyword">const</span> {<span class="hljs-attr">r</span>:inR, <span class="hljs-attr">g</span>:inG, <span class="hljs-attr">b</span>:inB, <span class="hljs-attr">a</span>:inA} = input;
        <span class="hljs-keyword">const</span> {<span class="hljs-attr">r</span>:outR, <span class="hljs-attr">g</span>:outG, <span class="hljs-attr">b</span>:outB, <span class="hljs-attr">a</span>:outA} = output;

        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) {

            <span class="hljs-keyword">if</span> (red) outR[i] = (inR[i] &gt; red) ? <span class="hljs-number">255</span> : <span class="hljs-number">0</span>;
            <span class="hljs-keyword">else</span> outR[i] = inR[i];

            <span class="hljs-keyword">if</span> (green) outG[i] = (inG[i] &gt; green) ? <span class="hljs-number">255</span> : <span class="hljs-number">0</span>;
            <span class="hljs-keyword">else</span> outG[i] = inG[i];

            <span class="hljs-keyword">if</span> (blue) outB[i] = (inB[i] &gt; blue) ? <span class="hljs-number">255</span> : <span class="hljs-number">0</span>;
            <span class="hljs-keyword">else</span> outB[i] = inB[i];

            <span class="hljs-keyword">if</span> (alpha) outA[i] = (inA[i] &gt; alpha) ? <span class="hljs-number">255</span> : <span class="hljs-number">0</span>;
            <span class="hljs-keyword">else</span> outA[i] = inA[i];
        }

        <span class="hljs-keyword">let</span> work = <span class="hljs-built_in">this</span>.cache.work.channels;
        <span class="hljs-keyword">if</span> (lineOut) <span class="hljs-built_in">this</span>.processResults(output, work, <span class="hljs-number">1</span> - opacity);
        <span class="hljs-keyword">else</span> <span class="hljs-built_in">this</span>.processResults(work, output, opacity);
    },</pre></div></div>
            
        </li>
        
        
        <li id="section-34">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-34">&#x00a7;</a>
              </div>
              <p><strong>blend</strong> - Using two source images (from the “lineIn” and “lineMix” arguments), combine their color information using various separable and non-separable blend modes (as defined by the W3C Compositing and Blending Level 1 recommendations. The blending method is determined by the String value supplied in the “blend” argument; permitted values are: ‘color-burn’, ‘color-dodge’, ‘darken’, ‘difference’, ‘exclusion’, ‘hard-light’, ‘lighten’, ‘lighter’, ‘multiply’, ‘overlay’, ‘screen’, ‘soft-light’, ‘color’, ‘hue’, ‘luminosity’, and ‘saturation’. Note that the source images may be of different sizes: the output (lineOut) image size will be the same as the source (NOT lineIn) image; the lineMix image can be moved relative to the lineIn image using the “offsetX” and “offsetY” arguments.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-string">&#x27;blend&#x27;</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">requirements</span>) </span>{

        <span class="hljs-keyword">let</span> [input, output, mix] = <span class="hljs-built_in">this</span>.getInputAndOutputChannels(requirements);

        <span class="hljs-keyword">let</span> len = output.r.length;

        <span class="hljs-keyword">let</span> {opacity, blend, offsetX, offsetY, lineOut} = requirements;

        <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> == opacity) opacity = <span class="hljs-number">1</span>;
        <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> == blend) blend = <span class="hljs-string">&#x27;&#x27;</span>;
        <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> == offsetX) offsetX = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> == offsetY) offsetY = <span class="hljs-number">0</span>;

        <span class="hljs-keyword">const</span> {<span class="hljs-attr">r</span>:inR, <span class="hljs-attr">g</span>:inG, <span class="hljs-attr">b</span>:inB, <span class="hljs-attr">a</span>:inA} = input;
        <span class="hljs-keyword">const</span> {<span class="hljs-attr">r</span>:outR, <span class="hljs-attr">g</span>:outG, <span class="hljs-attr">b</span>:outB, <span class="hljs-attr">a</span>:outA} = output;
        <span class="hljs-keyword">const</span> {<span class="hljs-attr">r</span>:mixR, <span class="hljs-attr">g</span>:mixG, <span class="hljs-attr">b</span>:mixB, <span class="hljs-attr">a</span>:mixA} = mix;

        <span class="hljs-keyword">let</span> [iWidth, iHeight, oWidth, oHeight, mWidth, mHeight] = <span class="hljs-built_in">this</span>.getInputAndOutputDimensions(requirements);

        <span class="hljs-keyword">const</span> copyPixel = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">fromPos, toPos, channel</span>) </span>{

            outR[toPos] = channel.r[fromPos];
            outG[toPos] = channel.g[fromPos];
            outB[toPos] = channel.b[fromPos];
            outA[toPos] = channel.a[fromPos];
        };

        <span class="hljs-keyword">const</span> getLinePositions = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">x, y</span>) </span>{

            <span class="hljs-keyword">let</span> ix = x,
                iy = y,
                mx = x - offsetX,
                my = y - offsetY;

            <span class="hljs-keyword">let</span> mPos = -<span class="hljs-number">1</span>,
                iPos = (iy * iWidth) + ix;

            <span class="hljs-keyword">if</span> (mx &gt;= <span class="hljs-number">0</span> &amp;&amp; mx &lt; mWidth &amp;&amp; my &gt;= <span class="hljs-number">0</span> &amp;&amp; my &lt; mHeight) mPos = (my * mWidth) + mx;

            <span class="hljs-keyword">return</span> [iPos, mPos];
        };

        <span class="hljs-keyword">const</span> getChannelNormals = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">i, m</span>) </span>{

            <span class="hljs-keyword">return</span> [
                input.r[i] / <span class="hljs-number">255</span>,
                input.g[i] / <span class="hljs-number">255</span>,
                input.b[i] / <span class="hljs-number">255</span>,
                input.a[i] / <span class="hljs-number">255</span>,
                mix.r[m] / <span class="hljs-number">255</span>,
                mix.g[m] / <span class="hljs-number">255</span>,
                mix.b[m] / <span class="hljs-number">255</span>,
                mix.a[m] / <span class="hljs-number">255</span>
            ];
        };

        <span class="hljs-keyword">const</span> alphaCalc = <span class="hljs-function">(<span class="hljs-params">dinA, dmixA</span>) =&gt;</span> (dinA + (dmixA * (<span class="hljs-number">1</span> - dinA))) * <span class="hljs-number">255</span>;

        <span class="hljs-keyword">switch</span> (blend) {

            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;color-burn&#x27;</span> :
                <span class="hljs-keyword">const</span> colorburnCalc = <span class="hljs-function">(<span class="hljs-params">din, dmix</span>) =&gt;</span> {
                    <span class="hljs-keyword">if</span> (dmix == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">255</span>;
                    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (din == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
                    <span class="hljs-keyword">return</span> (<span class="hljs-number">1</span> - <span class="hljs-built_in">Math</span>.min(<span class="hljs-number">1</span>, ((<span class="hljs-number">1</span> - dmix) / din ))) * <span class="hljs-number">255</span>;
                };
                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> y = <span class="hljs-number">0</span>; y &lt; iHeight; y++) {
                    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> x = <span class="hljs-number">0</span>; x &lt; iWidth; x++) {

                        <span class="hljs-keyword">let</span> [iPos, mPos] = getLinePositions(x, y);

                        <span class="hljs-keyword">if</span> (mPos &lt; <span class="hljs-number">0</span>) copyPixel(iPos, iPos, input);
                        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!inA[iPos]) copyPixel(mPos, iPos, mix);
                        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!mixA[mPos]) copyPixel(iPos, iPos, input);
                        <span class="hljs-keyword">else</span> {

                            <span class="hljs-keyword">let</span> [dinR, dinG, dinB, dinA, dmixR, dmixG, dmixB, dmixA] = getChannelNormals(iPos, mPos);

                            outR[iPos] = colorburnCalc(dinR, dmixR);
                            outG[iPos] = colorburnCalc(dinG, dmixG);
                            outB[iPos] = colorburnCalc(dinB, dmixB);
                            outA[iPos] = alphaCalc(dinA, dmixA);
                        }
                    }
                }
                <span class="hljs-keyword">break</span>;

            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;color-dodge&#x27;</span> :
                <span class="hljs-keyword">const</span> colordodgeCalc = <span class="hljs-function">(<span class="hljs-params">din, dmix</span>) =&gt;</span> {
                    <span class="hljs-keyword">if</span> (dmix == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
                    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (din == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">255</span>;
                    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Math</span>.min(<span class="hljs-number">1</span>, (dmix / (<span class="hljs-number">1</span> - din))) * <span class="hljs-number">255</span>;
                };
                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> y = <span class="hljs-number">0</span>; y &lt; iHeight; y++) {
                    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> x = <span class="hljs-number">0</span>; x &lt; iWidth; x++) {

                        <span class="hljs-keyword">let</span> [iPos, mPos] = getLinePositions(x, y);

                        <span class="hljs-keyword">if</span> (mPos &lt; <span class="hljs-number">0</span>) copyPixel(iPos, iPos, input);
                        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!inA[iPos]) copyPixel(mPos, iPos, mix);
                        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!mixA[mPos]) copyPixel(iPos, iPos, input);
                        <span class="hljs-keyword">else</span> {

                            <span class="hljs-keyword">let</span> [dinR, dinG, dinB, dinA, dmixR, dmixG, dmixB, dmixA] = getChannelNormals(iPos, mPos);

                            outR[iPos] = colordodgeCalc(dinR, dmixR);
                            outG[iPos] = colordodgeCalc(dinG, dmixG);
                            outB[iPos] = colordodgeCalc(dinB, dmixB);
                            outA[iPos] = alphaCalc(dinA, dmixA);
                        }
                    }
                }
                <span class="hljs-keyword">break</span>;

            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;darken&#x27;</span> :
                <span class="hljs-keyword">const</span> darkenCalc = <span class="hljs-function">(<span class="hljs-params">din, dmix</span>) =&gt;</span> (din &lt; dmix) ? din : dmix;
                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> y = <span class="hljs-number">0</span>; y &lt; iHeight; y++) {
                    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> x = <span class="hljs-number">0</span>; x &lt; iWidth; x++) {

                        <span class="hljs-keyword">let</span> [iPos, mPos] = getLinePositions(x, y);

                        <span class="hljs-keyword">if</span> (mPos &lt; <span class="hljs-number">0</span>) copyPixel(iPos, iPos, input);
                        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!inA[iPos]) copyPixel(mPos, iPos, mix);
                        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!mixA[mPos]) copyPixel(iPos, iPos, input);
                        <span class="hljs-keyword">else</span> {

                            outR[iPos] = darkenCalc(inR[iPos], mixR[mPos]);
                            outG[iPos] = darkenCalc(inG[iPos], mixG[mPos]);
                            outB[iPos] = darkenCalc(inB[iPos], mixB[mPos]);
                            outA[iPos] = alphaCalc(inA[iPos] / <span class="hljs-number">255</span>, mixA[mPos] / <span class="hljs-number">255</span>);
                        }
                    }
                }
                <span class="hljs-keyword">break</span>;

            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;difference&#x27;</span> :
                <span class="hljs-keyword">const</span> differenceCalc = <span class="hljs-function">(<span class="hljs-params">din, dmix</span>) =&gt;</span> <span class="hljs-built_in">Math</span>.abs(din - dmix) * <span class="hljs-number">255</span>;
                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> y = <span class="hljs-number">0</span>; y &lt; iHeight; y++) {
                    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> x = <span class="hljs-number">0</span>; x &lt; iWidth; x++) {

                        <span class="hljs-keyword">let</span> [iPos, mPos] = getLinePositions(x, y);

                        <span class="hljs-keyword">if</span> (mPos &lt; <span class="hljs-number">0</span>) copyPixel(iPos, iPos, input);
                        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!inA[iPos]) copyPixel(mPos, iPos, mix);
                        <span class="hljs-keyword">else</span> {

                            <span class="hljs-keyword">let</span> [dinR, dinG, dinB, dinA, dmixR, dmixG, dmixB, dmixA] = getChannelNormals(iPos, mPos);

                            outR[iPos] = differenceCalc(dinR, dmixR);
                            outG[iPos] = differenceCalc(dinG, dmixG);
                            outB[iPos] = differenceCalc(dinB, dmixB);
                            outA[iPos] = alphaCalc(dinA, dmixA);
                        }
                    }
                }
                <span class="hljs-keyword">break</span>;

            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;exclusion&#x27;</span> :
                <span class="hljs-keyword">const</span> exclusionCalc = <span class="hljs-function">(<span class="hljs-params">din, dmix</span>) =&gt;</span> (din + dmix - (<span class="hljs-number">2</span> * dmix * din)) * <span class="hljs-number">255</span>;
                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> y = <span class="hljs-number">0</span>; y &lt; iHeight; y++) {
                    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> x = <span class="hljs-number">0</span>; x &lt; iWidth; x++) {

                        <span class="hljs-keyword">let</span> [iPos, mPos] = getLinePositions(x, y);

                        <span class="hljs-keyword">if</span> (mPos &lt; <span class="hljs-number">0</span>) copyPixel(iPos, iPos, input);
                        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!inA[iPos]) copyPixel(mPos, iPos, mix);
                        <span class="hljs-keyword">else</span> {

                            <span class="hljs-keyword">let</span> [dinR, dinG, dinB, dinA, dmixR, dmixG, dmixB, dmixA] = getChannelNormals(iPos, mPos);

                            outR[iPos] = exclusionCalc(dinR, dmixR);
                            outG[iPos] = exclusionCalc(dinG, dmixG);
                            outB[iPos] = exclusionCalc(dinB, dmixB);
                            outA[iPos] = alphaCalc(dinA, dmixA);
                        }
                    }
                }
                <span class="hljs-keyword">break</span>;

            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;hard-light&#x27;</span> :
                <span class="hljs-keyword">const</span> hardlightCalc = <span class="hljs-function">(<span class="hljs-params">din, dmix</span>) =&gt;</span> (din &lt;= <span class="hljs-number">0.5</span>) ? (din * dmix) * <span class="hljs-number">255</span> : (dmix + (din - (dmix * din))) * <span class="hljs-number">255</span>;
                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> y = <span class="hljs-number">0</span>; y &lt; iHeight; y++) {
                    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> x = <span class="hljs-number">0</span>; x &lt; iWidth; x++) {

                        <span class="hljs-keyword">let</span> [iPos, mPos] = getLinePositions(x, y);

                        <span class="hljs-keyword">if</span> (mPos &lt; <span class="hljs-number">0</span>) copyPixel(iPos, iPos, input);
                        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!inA[iPos]) copyPixel(mPos, iPos, mix);
                        <span class="hljs-keyword">else</span> {

                            <span class="hljs-keyword">let</span> [dinR, dinG, dinB, dinA, dmixR, dmixG, dmixB, dmixA] = getChannelNormals(iPos, mPos);

                            outR[iPos] = hardlightCalc(dinR, dmixR);
                            outG[iPos] = hardlightCalc(dinG, dmixG);
                            outB[iPos] = hardlightCalc(dinB, dmixB);
                            outA[iPos] = alphaCalc(dinA, dmixA);
                        }
                    }
                }
                <span class="hljs-keyword">break</span>;

            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;lighten&#x27;</span> :
                <span class="hljs-keyword">const</span> lightenCalc = <span class="hljs-function">(<span class="hljs-params">din, dmix</span>) =&gt;</span> (din &gt; dmix) ? din : dmix;
                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> y = <span class="hljs-number">0</span>; y &lt; iHeight; y++) {
                    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> x = <span class="hljs-number">0</span>; x &lt; iWidth; x++) {

                        <span class="hljs-keyword">let</span> [iPos, mPos] = getLinePositions(x, y);

                        <span class="hljs-keyword">if</span> (mPos &lt; <span class="hljs-number">0</span>) copyPixel(iPos, iPos, input);
                        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!inA[iPos]) copyPixel(mPos, iPos, mix);
                        <span class="hljs-keyword">else</span> {

                            outR[iPos] = lightenCalc(inR[iPos], mixR[mPos]);
                            outG[iPos] = lightenCalc(inG[iPos], mixG[mPos]);
                            outB[iPos] = lightenCalc(inB[iPos], mixB[mPos]);
                            outA[iPos] = alphaCalc(inA[iPos] / <span class="hljs-number">255</span>, mixA[mPos] / <span class="hljs-number">255</span>);
                        }
                    }
                }
                <span class="hljs-keyword">break</span>;

            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;lighter&#x27;</span> :
                <span class="hljs-keyword">const</span> lighterCalc = <span class="hljs-function">(<span class="hljs-params">din, dmix</span>) =&gt;</span> (din + dmix) * <span class="hljs-number">255</span>;
                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> y = <span class="hljs-number">0</span>; y &lt; iHeight; y++) {
                    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> x = <span class="hljs-number">0</span>; x &lt; iWidth; x++) {

                        <span class="hljs-keyword">let</span> [iPos, mPos] = getLinePositions(x, y);

                        <span class="hljs-keyword">if</span> (mPos &lt; <span class="hljs-number">0</span>) copyPixel(iPos, iPos, input);
                        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!inA[iPos]) copyPixel(mPos, iPos, mix);
                        <span class="hljs-keyword">else</span> {

                            <span class="hljs-keyword">let</span> [dinR, dinG, dinB, dinA, dmixR, dmixG, dmixB, dmixA] = getChannelNormals(iPos, mPos);

                            outR[iPos] = lighterCalc(dinR, dmixR);
                            outG[iPos] = lighterCalc(dinG, dmixG);
                            outB[iPos] = lighterCalc(dinB, dmixB);
                            outA[iPos] = alphaCalc(dinA, dmixA);
                        }
                    }
                }
                <span class="hljs-keyword">break</span>;

            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;multiply&#x27;</span> :
                <span class="hljs-keyword">const</span> multiplyCalc = <span class="hljs-function">(<span class="hljs-params">din, dmix</span>) =&gt;</span> din * dmix * <span class="hljs-number">255</span>;
                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> y = <span class="hljs-number">0</span>; y &lt; iHeight; y++) {
                    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> x = <span class="hljs-number">0</span>; x &lt; iWidth; x++) {

                        <span class="hljs-keyword">let</span> [iPos, mPos] = getLinePositions(x, y);

                        <span class="hljs-keyword">if</span> (mPos &lt; <span class="hljs-number">0</span>) copyPixel(iPos, iPos, input);
                        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!inA[iPos]) copyPixel(mPos, iPos, mix);
                        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!mixA[mPos]) copyPixel(iPos, iPos, input);
                        <span class="hljs-keyword">else</span> {

                            <span class="hljs-keyword">let</span> [dinR, dinG, dinB, dinA, dmixR, dmixG, dmixB, dmixA] = getChannelNormals(iPos, mPos);

                            outR[iPos] = multiplyCalc(dinR, dmixR);
                            outG[iPos] = multiplyCalc(dinG, dmixG);
                            outB[iPos] = multiplyCalc(dinB, dmixB);
                            outA[iPos] = alphaCalc(dinA, dmixA);
                        }
                    }
                }
                <span class="hljs-keyword">break</span>;

            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;overlay&#x27;</span> :
                <span class="hljs-keyword">const</span> overlayCalc = <span class="hljs-function">(<span class="hljs-params">din, dmix</span>) =&gt;</span> (din &gt;= <span class="hljs-number">0.5</span>) ? (din * dmix) * <span class="hljs-number">255</span> : (dmix + (din - (dmix * din))) * <span class="hljs-number">255</span>;
                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> y = <span class="hljs-number">0</span>; y &lt; iHeight; y++) {
                    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> x = <span class="hljs-number">0</span>; x &lt; iWidth; x++) {

                        <span class="hljs-keyword">let</span> [iPos, mPos] = getLinePositions(x, y);

                        <span class="hljs-keyword">if</span> (mPos &lt; <span class="hljs-number">0</span>) copyPixel(iPos, iPos, input);
                        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!inA[iPos]) copyPixel(mPos, iPos, mix);
                        <span class="hljs-keyword">else</span> {

                            <span class="hljs-keyword">let</span> [dinR, dinG, dinB, dinA, dmixR, dmixG, dmixB, dmixA] = getChannelNormals(iPos, mPos);

                            outR[iPos] = overlayCalc(dinR, dmixR);
                            outG[iPos] = overlayCalc(dinG, dmixG);
                            outB[iPos] = overlayCalc(dinB, dmixB);
                            outA[iPos] = alphaCalc(dinA, dmixA);
                        }
                    }
                }
                <span class="hljs-keyword">break</span>;

            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;screen&#x27;</span> :
                <span class="hljs-keyword">const</span> screenCalc = <span class="hljs-function">(<span class="hljs-params">din, dmix</span>) =&gt;</span> (dmix + (din - (dmix * din))) * <span class="hljs-number">255</span>;
                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> y = <span class="hljs-number">0</span>; y &lt; iHeight; y++) {
                    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> x = <span class="hljs-number">0</span>; x &lt; iWidth; x++) {

                        <span class="hljs-keyword">let</span> [iPos, mPos] = getLinePositions(x, y);

                        <span class="hljs-keyword">if</span> (mPos &lt; <span class="hljs-number">0</span>) copyPixel(iPos, iPos, input);
                        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!inA[iPos]) copyPixel(mPos, iPos, mix);
                        <span class="hljs-keyword">else</span> {

                            <span class="hljs-keyword">let</span> [dinR, dinG, dinB, dinA, dmixR, dmixG, dmixB, dmixA] = getChannelNormals(iPos, mPos);

                            outR[iPos] = screenCalc(dinR, dmixR);
                            outG[iPos] = screenCalc(dinG, dmixG);
                            outB[iPos] = screenCalc(dinB, dmixB);
                            outA[iPos] = alphaCalc(dinA, dmixA);
                        }
                    }
                }
                <span class="hljs-keyword">break</span>;

            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;soft-light&#x27;</span> :
                <span class="hljs-keyword">const</span> softlightCalc = <span class="hljs-function">(<span class="hljs-params">din, dmix</span>) =&gt;</span> {

                    <span class="hljs-keyword">let</span> d = (dmix &lt;= <span class="hljs-number">0.25</span>) ?
                        ((((<span class="hljs-number">16</span> * dmix) - <span class="hljs-number">12</span>) * dmix) + <span class="hljs-number">4</span>) * dmix :
                        <span class="hljs-built_in">Math</span>.sqrt(dmix);

                    <span class="hljs-keyword">if</span> (din &lt;= <span class="hljs-number">0.5</span>) <span class="hljs-keyword">return</span> (dmix - ((<span class="hljs-number">1</span> - (<span class="hljs-number">2</span> * din)) * dmix * (<span class="hljs-number">1</span> - dmix))) * <span class="hljs-number">255</span>;
                    <span class="hljs-keyword">return</span> (dmix + (((<span class="hljs-number">2</span> * din) - <span class="hljs-number">1</span>) * (d - dmix))) * <span class="hljs-number">255</span>;
                };
                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> y = <span class="hljs-number">0</span>; y &lt; iHeight; y++) {
                    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> x = <span class="hljs-number">0</span>; x &lt; iWidth; x++) {

                        <span class="hljs-keyword">let</span> [iPos, mPos] = getLinePositions(x, y);

                        <span class="hljs-keyword">if</span> (mPos &lt; <span class="hljs-number">0</span>) copyPixel(iPos, iPos, input);
                        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!inA[iPos]) copyPixel(mPos, iPos, mix);
                        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!mixA[mPos]) copyPixel(iPos, iPos, input);
                        <span class="hljs-keyword">else</span> {

                            <span class="hljs-keyword">let</span> [dinR, dinG, dinB, dinA, dmixR, dmixG, dmixB, dmixA] = getChannelNormals(iPos, mPos);

                            outR[iPos] = softlightCalc(dinR, dmixR);
                            outG[iPos] = softlightCalc(dinG, dmixG);
                            outB[iPos] = softlightCalc(dinB, dmixB);
                            outA[iPos] = alphaCalc(dinA, dmixA);
                        }
                    }
                }
                <span class="hljs-keyword">break</span>;

            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;color&#x27;</span> :
                <span class="hljs-keyword">const</span> colorCalc = <span class="hljs-function">(<span class="hljs-params">iR, iG, iB, mR, mG, mB</span>) =&gt;</span> {

                    <span class="hljs-keyword">let</span> [iH, iS, iL] = <span class="hljs-built_in">this</span>.getHSLfromRGB(iR, iG, iB);
                    <span class="hljs-keyword">let</span> [mH, mS, mL] = <span class="hljs-built_in">this</span>.getHSLfromRGB(mR, mG, mB);

                    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.getRGBfromHSL(iH, iS, mL);
                }
                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> y = <span class="hljs-number">0</span>; y &lt; iHeight; y++) {
                    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> x = <span class="hljs-number">0</span>; x &lt; iWidth; x++) {

                        <span class="hljs-keyword">let</span> [iPos, mPos] = getLinePositions(x, y);

                        <span class="hljs-keyword">if</span> (mPos &lt; <span class="hljs-number">0</span>) copyPixel(iPos, iPos, input);
                        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!inA[iPos]) copyPixel(mPos, iPos, mix);
                        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!mixA[mPos]) copyPixel(iPos, iPos, input);
                        <span class="hljs-keyword">else</span> {

                            <span class="hljs-keyword">let</span> [dinR, dinG, dinB, dinA, dmixR, dmixG, dmixB, dmixA] = getChannelNormals(iPos, mPos);

                            <span class="hljs-keyword">let</span> [cr, cg, cb] = colorCalc(dinR, dinG, dinB, dmixR, dmixG, dmixB);
                            outR[iPos] = cr;
                            outG[iPos] = cg;
                            outB[iPos] = cb;
                            outA[iPos] = alphaCalc(dinA, dmixA);
                        }
                    }
                }
                <span class="hljs-keyword">break</span>;

            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;hue&#x27;</span> :
                <span class="hljs-keyword">const</span> hueCalc = <span class="hljs-function">(<span class="hljs-params">iR, iG, iB, mR, mG, mB</span>) =&gt;</span> {

                    <span class="hljs-keyword">let</span> [iH, iS, iL] = <span class="hljs-built_in">this</span>.getHSLfromRGB(iR, iG, iB);
                    <span class="hljs-keyword">let</span> [mH, mS, mL] = <span class="hljs-built_in">this</span>.getHSLfromRGB(mR, mG, mB);

                    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.getRGBfromHSL(iH, mS, mL);
                }
                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> y = <span class="hljs-number">0</span>; y &lt; iHeight; y++) {
                    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> x = <span class="hljs-number">0</span>; x &lt; iWidth; x++) {

                        <span class="hljs-keyword">let</span> [iPos, mPos] = getLinePositions(x, y);

                        <span class="hljs-keyword">if</span> (mPos &lt; <span class="hljs-number">0</span>) copyPixel(iPos, iPos, input);
                        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!inA[iPos]) copyPixel(mPos, iPos, mix);
                        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!mixA[mPos]) copyPixel(iPos, iPos, input);
                        <span class="hljs-keyword">else</span> {

                            <span class="hljs-keyword">let</span> [dinR, dinG, dinB, dinA, dmixR, dmixG, dmixB, dmixA] = getChannelNormals(iPos, mPos);

                            <span class="hljs-keyword">let</span> [cr, cg, cb] = hueCalc(dinR, dinG, dinB, dmixR, dmixG, dmixB);
                            outR[iPos] = cr;
                            outG[iPos] = cg;
                            outB[iPos] = cb;
                            outA[iPos] = alphaCalc(dinA, dmixA);
                        }
                    }
                }
                <span class="hljs-keyword">break</span>;

            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;luminosity&#x27;</span> :
                <span class="hljs-keyword">const</span> luminosityCalc = <span class="hljs-function">(<span class="hljs-params">iR, iG, iB, mR, mG, mB</span>) =&gt;</span> {

                    <span class="hljs-keyword">let</span> [iH, iS, iL] = <span class="hljs-built_in">this</span>.getHSLfromRGB(iR, iG, iB);
                    <span class="hljs-keyword">let</span> [mH, mS, mL] = <span class="hljs-built_in">this</span>.getHSLfromRGB(mR, mG, mB);

                    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.getRGBfromHSL(mH, mS, iL);
                }
                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> y = <span class="hljs-number">0</span>; y &lt; iHeight; y++) {
                    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> x = <span class="hljs-number">0</span>; x &lt; iWidth; x++) {

                        <span class="hljs-keyword">let</span> [iPos, mPos] = getLinePositions(x, y);

                        <span class="hljs-keyword">if</span> (mPos &lt; <span class="hljs-number">0</span>) copyPixel(iPos, iPos, input);
                        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!inA[iPos]) copyPixel(mPos, iPos, mix);
                        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!mixA[mPos]) copyPixel(iPos, iPos, input);
                        <span class="hljs-keyword">else</span> {

                            <span class="hljs-keyword">let</span> [dinR, dinG, dinB, dinA, dmixR, dmixG, dmixB, dmixA] = getChannelNormals(iPos, mPos);

                            <span class="hljs-keyword">let</span> [cr, cg, cb] = luminosityCalc(dinR, dinG, dinB, dmixR, dmixG, dmixB);
                            outR[iPos] = cr;
                            outG[iPos] = cg;
                            outB[iPos] = cb;
                            outA[iPos] = alphaCalc(dinA, dmixA);
                        }
                    }
                }
                <span class="hljs-keyword">break</span>;

            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;saturation&#x27;</span> :
                <span class="hljs-keyword">const</span> saturationCalc = <span class="hljs-function">(<span class="hljs-params">iR, iG, iB, mR, mG, mB</span>) =&gt;</span> {

                    <span class="hljs-keyword">let</span> [iH, iS, iL] = <span class="hljs-built_in">this</span>.getHSLfromRGB(iR, iG, iB);
                    <span class="hljs-keyword">let</span> [mH, mS, mL] = <span class="hljs-built_in">this</span>.getHSLfromRGB(mR, mG, mB);

                    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.getRGBfromHSL(mH, iS, mL);
                }
                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> y = <span class="hljs-number">0</span>; y &lt; iHeight; y++) {
                    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> x = <span class="hljs-number">0</span>; x &lt; iWidth; x++) {

                        <span class="hljs-keyword">let</span> [iPos, mPos] = getLinePositions(x, y);

                        <span class="hljs-keyword">if</span> (mPos &lt; <span class="hljs-number">0</span>) copyPixel(iPos, iPos, input);
                        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!inA[iPos]) copyPixel(mPos, iPos, mix);
                        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!mixA[mPos]) copyPixel(iPos, iPos, input);
                        <span class="hljs-keyword">else</span> {

                            <span class="hljs-keyword">let</span> [dinR, dinG, dinB, dinA, dmixR, dmixG, dmixB, dmixA] = getChannelNormals(iPos, mPos);

                            <span class="hljs-keyword">let</span> [cr, cg, cb] = saturationCalc(dinR, dinG, dinB, dmixR, dmixG, dmixB);
                            outR[iPos] = cr;
                            outG[iPos] = cg;
                            outB[iPos] = cb;
                            outA[iPos] = alphaCalc(dinA, dmixA);
                        }
                    }
                }
                <span class="hljs-keyword">break</span>;

            <span class="hljs-keyword">default</span>:
                <span class="hljs-keyword">const</span> normalCalc = <span class="hljs-function">(<span class="hljs-params">Cs, As, Cb, Ab</span>) =&gt;</span> (As * Cs) + (Ab * Cb * (<span class="hljs-number">1</span> - As));
                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> y = <span class="hljs-number">0</span>; y &lt; iHeight; y++) {
                    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> x = <span class="hljs-number">0</span>; x &lt; iWidth; x++) {

                        <span class="hljs-keyword">let</span> [iPos, mPos] = getLinePositions(x, y);

                        <span class="hljs-keyword">if</span> (mPos &lt; <span class="hljs-number">0</span>) copyPixel(iPos, iPos, input);
                        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!inA[iPos]) copyPixel(mPos, iPos, mix);
                        <span class="hljs-keyword">else</span> {

                            <span class="hljs-keyword">let</span> dinA = inA[iPos] / <span class="hljs-number">255</span>,
                                dmixA = mixA[mPos] / <span class="hljs-number">255</span>;

                            outR[iPos] = normalCalc(inR[iPos], dinA, mixR[mPos], dmixA);
                            outG[iPos] = normalCalc(inG[iPos], dinA, mixG[mPos], dmixA);
                            outB[iPos] = normalCalc(inB[iPos], dinA, mixB[mPos], dmixA);
                            outA[iPos] = alphaCalc(dinA, dmixA)
                        }
                    }
                }
        }

        <span class="hljs-keyword">let</span> work = <span class="hljs-built_in">this</span>.cache.work.channels;
        <span class="hljs-keyword">if</span> (lineOut) <span class="hljs-built_in">this</span>.processResults(output, work, <span class="hljs-number">1</span> - opacity);
        <span class="hljs-keyword">else</span> <span class="hljs-built_in">this</span>.processResults(work, output, opacity);
    },</pre></div></div>
            
        </li>
        
        
        <li id="section-35">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-35">&#x00a7;</a>
              </div>
              <p><strong>blur</strong> - Performs a multi-loop, two-step ‘horizontal-then-vertical averaging sweep’ calculation across all pixels to create a blur effect. Note that this filter is expensive, thus much slower to complete compared to other filter effects.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-string">&#x27;blur&#x27;</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">requirements</span>) </span>{

        <span class="hljs-keyword">let</span> [input, output] = <span class="hljs-built_in">this</span>.getInputAndOutputChannels(requirements);

        <span class="hljs-keyword">let</span> len = input.r.length;

        <span class="hljs-keyword">let</span> {opacity, radius, passes, processVertical, processHorizontal, includeRed, includeGreen, includeBlue, includeAlpha, step, lineOut} = requirements;

        <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> == opacity) opacity = <span class="hljs-number">1</span>;
        <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> == radius) radius = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> == passes) passes = <span class="hljs-number">1</span>;
        <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> == processVertical) processVertical = <span class="hljs-literal">true</span>;
        <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> == processHorizontal) processHorizontal = <span class="hljs-literal">true</span>;
        <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> == includeRed) includeRed = <span class="hljs-literal">true</span>;
        <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> == includeGreen) includeGreen = <span class="hljs-literal">true</span>;
        <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> == includeBlue) includeBlue = <span class="hljs-literal">true</span>;
        <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> == includeAlpha) includeAlpha = <span class="hljs-literal">false</span>;
        <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> == step) step = <span class="hljs-number">1</span>;

        <span class="hljs-keyword">let</span> horizontalBlurGrid, verticalBlurGrid;

        <span class="hljs-keyword">if</span> (processHorizontal || processVertical) {

            <span class="hljs-keyword">let</span> grid = <span class="hljs-built_in">this</span>.buildImageGrid();

            <span class="hljs-keyword">if</span> (processHorizontal)  horizontalBlurGrid = <span class="hljs-built_in">this</span>.buildHorizontalBlur(grid, radius);

            <span class="hljs-keyword">if</span> (processVertical) verticalBlurGrid = <span class="hljs-built_in">this</span>.buildVerticalBlur(grid, radius);
        }

        <span class="hljs-keyword">const</span> {<span class="hljs-attr">r</span>:inR, <span class="hljs-attr">g</span>:inG, <span class="hljs-attr">b</span>:inB, <span class="hljs-attr">a</span>:inA} = input;
        <span class="hljs-keyword">const</span> {<span class="hljs-attr">r</span>:outR, <span class="hljs-attr">g</span>:outG, <span class="hljs-attr">b</span>:outB, <span class="hljs-attr">a</span>:outA} = output;

        <span class="hljs-keyword">const</span> getValue = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">flag, gridStore, pos, holdChannel, alpha</span>) </span>{

            <span class="hljs-keyword">if</span> (flag) {

                <span class="hljs-keyword">let</span> h = gridStore[pos];

                <span class="hljs-keyword">if</span> (h != <span class="hljs-literal">null</span>) {

                    <span class="hljs-keyword">let</span> l = h.length,
                        counter = <span class="hljs-number">0</span>,
                        total = <span class="hljs-number">0</span>;

                    <span class="hljs-keyword">if</span> (alpha) {

                        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> t = <span class="hljs-number">0</span>; t &lt; l; t += step) {

                            <span class="hljs-keyword">if</span> (alpha[h[t]]) {

                                total += holdChannel[h[t]];
                                counter++;
                            }
                        }
                        <span class="hljs-keyword">return</span> total / counter;
                    }
                    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> t = <span class="hljs-number">0</span>; t &lt; l; t++) {
                        total += holdChannel[h[t]];
                    }
                    <span class="hljs-keyword">return</span> total / l;
                }
            }
            <span class="hljs-keyword">return</span> holdChannel[pos];
        }

        <span class="hljs-keyword">if</span> (!passes || (!processHorizontal &amp;&amp; !processVertical)) <span class="hljs-built_in">this</span>.copyOver(input, output);
        <span class="hljs-keyword">else</span> {

            <span class="hljs-keyword">const</span> hold = <span class="hljs-built_in">this</span>.createResultObject(len);
            <span class="hljs-keyword">const</span> {<span class="hljs-attr">r</span>:holdR, <span class="hljs-attr">g</span>:holdG, <span class="hljs-attr">b</span>:holdB, <span class="hljs-attr">a</span>:holdA} = hold;

            <span class="hljs-built_in">this</span>.copyOver(input, hold);

            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> pass = <span class="hljs-number">0</span>; pass &lt; passes; pass++) {

                <span class="hljs-keyword">if</span> (processHorizontal) {

                    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> k = <span class="hljs-number">0</span>; k &lt; len; k++) {

                        <span class="hljs-keyword">if</span> (includeAlpha || holdA[k]) {

                            outR[k] = getValue(includeRed, horizontalBlurGrid, k, holdR, holdA);
                            outG[k] = getValue(includeGreen, horizontalBlurGrid, k, holdG, holdA);
                            outB[k] = getValue(includeBlue, horizontalBlurGrid, k, holdB, holdA);
                            outA[k] = getValue(includeAlpha, horizontalBlurGrid, k, holdA, <span class="hljs-literal">false</span>);
                        }
                    }
                    <span class="hljs-keyword">if</span> (processVertical || pass &lt; passes - <span class="hljs-number">1</span>) <span class="hljs-built_in">this</span>.copyOver(output, hold);
                }

                <span class="hljs-keyword">if</span> (processVertical) {

                    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> k = <span class="hljs-number">0</span>; k &lt; len; k++) {

                        <span class="hljs-keyword">if</span> (includeAlpha || holdA[k]) {

                            outR[k] = getValue(includeRed, verticalBlurGrid, k, holdR, holdA);
                            outG[k] = getValue(includeGreen, verticalBlurGrid, k, holdG, holdA);
                            outB[k] = getValue(includeBlue, verticalBlurGrid, k, holdB, holdA);
                            outA[k] = getValue(includeAlpha, verticalBlurGrid, k, holdA, <span class="hljs-literal">false</span>);
                        }
                    }
                    <span class="hljs-keyword">if</span> (pass &lt; passes - <span class="hljs-number">1</span>) <span class="hljs-built_in">this</span>.copyOver(output, hold);
                }
            }
        }
        <span class="hljs-keyword">let</span> work = <span class="hljs-built_in">this</span>.cache.work.channels;
        <span class="hljs-keyword">if</span> (lineOut) <span class="hljs-built_in">this</span>.processResults(output, work, <span class="hljs-number">1</span> - opacity);
        <span class="hljs-keyword">else</span> <span class="hljs-built_in">this</span>.processResults(work, output, opacity);
    },</pre></div></div>
            
        </li>
        
        
        <li id="section-36">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-36">&#x00a7;</a>
              </div>
              <p><strong>channels-to-alpha</strong> - Calculates an average value from each pixel’s included channels and applies that value to the alpha channel.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-string">&#x27;channels-to-alpha&#x27;</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">requirements</span>) </span>{

        <span class="hljs-keyword">let</span> [input, output] = <span class="hljs-built_in">this</span>.getInputAndOutputChannels(requirements);

        <span class="hljs-keyword">let</span> len = input.r.length;

        <span class="hljs-keyword">let</span> {opacity, includeRed, includeGreen, includeBlue, lineOut} = requirements;

        <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> == opacity) opacity = <span class="hljs-number">1</span>;
        <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> == includeRed) includeRed = <span class="hljs-literal">true</span>;
        <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> == includeGreen) includeGreen = <span class="hljs-literal">true</span>;
        <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> == includeBlue) includeBlue = <span class="hljs-literal">true</span>;

        <span class="hljs-keyword">let</span> divisor = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">if</span> (includeRed) divisor++;
        <span class="hljs-keyword">if</span> (includeGreen) divisor++;
        <span class="hljs-keyword">if</span> (includeBlue) divisor++;

        <span class="hljs-keyword">const</span> {<span class="hljs-attr">r</span>:inR, <span class="hljs-attr">g</span>:inG, <span class="hljs-attr">b</span>:inB, <span class="hljs-attr">a</span>:inA} = input;
        <span class="hljs-keyword">const</span> {<span class="hljs-attr">r</span>:outR, <span class="hljs-attr">g</span>:outG, <span class="hljs-attr">b</span>:outB, <span class="hljs-attr">a</span>:outA} = output;

        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) {

            outR[i] = inR[i];
            outG[i] = inG[i];
            outB[i] = inB[i];

            <span class="hljs-keyword">if</span> (divisor) {

                <span class="hljs-keyword">let</span> avg = <span class="hljs-number">0</span>;

                <span class="hljs-keyword">if</span> (includeRed) avg += inR[i];
                <span class="hljs-keyword">if</span> (includeGreen) avg += inG[i];
                <span class="hljs-keyword">if</span> (includeBlue) avg += inB[i];

                avg = <span class="hljs-built_in">Math</span>.floor(avg / divisor);

                outA[i] = avg;
            }
            <span class="hljs-keyword">else</span> outA[i] = inA[i];
        }
        <span class="hljs-keyword">let</span> work = <span class="hljs-built_in">this</span>.cache.work.channels;
        <span class="hljs-keyword">if</span> (lineOut) <span class="hljs-built_in">this</span>.processResults(output, work, <span class="hljs-number">1</span> - opacity);
        <span class="hljs-keyword">else</span> <span class="hljs-built_in">this</span>.processResults(work, output, opacity);
    },</pre></div></div>
            
        </li>
        
        
        <li id="section-37">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-37">&#x00a7;</a>
              </div>
              <p><strong>chroma</strong> - Using an array of ‘range’ arrays, determine whether a pixel’s values lie entirely within a range’s values and, if true, sets that pixel’s alpha channel value to zero. Each ‘range’ array comprises six Numbers representing [minimum-red, minimum-green, minimum-blue, maximum-red, maximum-green, maximum-blue] values.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-string">&#x27;chroma&#x27;</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">requirements</span>) </span>{

        <span class="hljs-keyword">let</span> [input, output] = <span class="hljs-built_in">this</span>.getInputAndOutputChannels(requirements);

        <span class="hljs-keyword">let</span> len = input.r.length;

        <span class="hljs-keyword">let</span> {opacity, ranges, lineOut} = requirements;

        <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> == opacity) opacity = <span class="hljs-number">1</span>;
        <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> == ranges) ranges = [];

        <span class="hljs-keyword">const</span> {<span class="hljs-attr">r</span>:inR, <span class="hljs-attr">g</span>:inG, <span class="hljs-attr">b</span>:inB, <span class="hljs-attr">a</span>:inA} = input;
        <span class="hljs-keyword">const</span> {<span class="hljs-attr">r</span>:outR, <span class="hljs-attr">g</span>:outG, <span class="hljs-attr">b</span>:outB, <span class="hljs-attr">a</span>:outA} = output;

        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; len; j++) {

            <span class="hljs-keyword">let</span> flag = <span class="hljs-literal">false</span>;

            <span class="hljs-keyword">let</span> r = inR[j],
                g = inG[j],
                b = inB[j];

            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>, iz = ranges.length; i &lt; iz; i++) {

                <span class="hljs-keyword">let</span> range = ranges[i];

                <span class="hljs-keyword">let</span> [minR, minG, minB, maxR, maxG, maxB] = ranges[i];

                <span class="hljs-keyword">if</span> (r &gt;= minR &amp;&amp; r &lt;= maxR &amp;&amp; g &gt;= minG &amp;&amp; g &lt;= maxG &amp;&amp; b &gt;= minB &amp;&amp; b &lt;= maxB) {
                    flag = <span class="hljs-literal">true</span>;
                    <span class="hljs-keyword">break</span>;
                }

            }
            outR[j] = inR[j];
            outG[j] = inG[j];
            outB[j] = inB[j];
            outA[j] = (flag) ? <span class="hljs-number">0</span> : inA[j];
        }

        <span class="hljs-keyword">let</span> work = <span class="hljs-built_in">this</span>.cache.work.channels;
        <span class="hljs-keyword">if</span> (lineOut) <span class="hljs-built_in">this</span>.processResults(output, work, <span class="hljs-number">1</span> - opacity);
        <span class="hljs-keyword">else</span> <span class="hljs-built_in">this</span>.processResults(work, output, opacity);
    },</pre></div></div>
            
        </li>
        
        
        <li id="section-38">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-38">&#x00a7;</a>
              </div>
              <p><strong>clamp-channels</strong> - Clamp each color channel to a range set by lowColor and highColor values</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-string">&#x27;clamp-channels&#x27;</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">requirements</span>) </span>{

        <span class="hljs-keyword">let</span> [input, output] = <span class="hljs-built_in">this</span>.getInputAndOutputChannels(requirements);

        <span class="hljs-keyword">let</span> len = input.r.length;

        <span class="hljs-keyword">let</span> {opacity, lowRed, lowGreen, lowBlue, highRed, highGreen, highBlue, lineOut} = requirements;

        <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> == opacity) opacity = <span class="hljs-number">1</span>;
        <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> == lowRed) lowRed = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> == lowGreen) lowGreen = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> == lowBlue) lowBlue = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> == highRed) highRed = <span class="hljs-number">255</span>;
        <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> == highGreen) highGreen = <span class="hljs-number">255</span>;
        <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> == highBlue) highBlue = <span class="hljs-number">255</span>;

        <span class="hljs-keyword">const</span> dR = highRed - lowRed,
            dG = highGreen - lowGreen,
            dB = highBlue - lowBlue;

        <span class="hljs-keyword">const</span> {<span class="hljs-attr">r</span>:inR, <span class="hljs-attr">g</span>:inG, <span class="hljs-attr">b</span>:inB, <span class="hljs-attr">a</span>:inA} = input;
        <span class="hljs-keyword">const</span> {<span class="hljs-attr">r</span>:outR, <span class="hljs-attr">g</span>:outG, <span class="hljs-attr">b</span>:outB, <span class="hljs-attr">a</span>:outA} = output;

        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) {

            <span class="hljs-keyword">if</span> (inA[i]) {

                <span class="hljs-keyword">let</span> r = inR[i] / <span class="hljs-number">255</span>,
                    g = inG[i] / <span class="hljs-number">255</span>,
                    b = inB[i] / <span class="hljs-number">255</span>;

                outR[i] = lowRed + (r * dR);
                outG[i] = lowGreen + (g * dG);
                outB[i] = lowBlue + (b * dB);
                outA[i] = inA[i];
            }
            <span class="hljs-keyword">else</span> {
                outR[i] = inR[i];
                outG[i] = inG[i];
                outB[i] = inB[i];
                outA[i] = inA[i];
            }
        }
        <span class="hljs-keyword">let</span> work = <span class="hljs-built_in">this</span>.cache.work.channels;
        <span class="hljs-keyword">if</span> (lineOut) <span class="hljs-built_in">this</span>.processResults(output, work, <span class="hljs-number">1</span> - opacity);
        <span class="hljs-keyword">else</span> <span class="hljs-built_in">this</span>.processResults(work, output, opacity);
    },</pre></div></div>
            
        </li>
        
        
        <li id="section-39">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-39">&#x00a7;</a>
              </div>
              <p><strong>colors-to-alpha</strong> - Determine the alpha channel value for each pixel depending on the closeness to that pixel’s color channel values to a reference color supplied in the “red”, “green” and “blue” arguments. The sensitivity of the effect can be manipulated using the “transparentAt” and “opaqueAt” values, both of which lie in the range 0-1.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-string">&#x27;colors-to-alpha&#x27;</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">requirements</span>) </span>{

        <span class="hljs-keyword">let</span> [input, output] = <span class="hljs-built_in">this</span>.getInputAndOutputChannels(requirements);

        <span class="hljs-keyword">let</span> len = input.r.length;

        <span class="hljs-keyword">let</span> {opacity, red, green, blue, opaqueAt, transparentAt, lineOut} = requirements;

        <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> == opacity) opacity = <span class="hljs-number">1</span>;
        <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> == red) red = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> == green) green = <span class="hljs-number">255</span>;
        <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> == blue) blue = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> == opaqueAt) opaqueAt = <span class="hljs-number">1</span>;
        <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> == transparentAt) transparentAt = <span class="hljs-number">0</span>;

        <span class="hljs-keyword">const</span> maxDiff = <span class="hljs-built_in">Math</span>.max(((red + green + blue) / <span class="hljs-number">3</span>), (((<span class="hljs-number">255</span> - red) + (<span class="hljs-number">255</span> - green) + (<span class="hljs-number">255</span> - blue)) / <span class="hljs-number">3</span>)),
            transparent = transparentAt * maxDiff,
            opaque = opaqueAt * maxDiff,
            range = opaque - transparent;

        <span class="hljs-keyword">const</span> getValue = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">r, g, b</span>) </span>{

            <span class="hljs-keyword">let</span> diff = (<span class="hljs-built_in">Math</span>.abs(red - r) + <span class="hljs-built_in">Math</span>.abs(green - g) + <span class="hljs-built_in">Math</span>.abs(blue - b)) / <span class="hljs-number">3</span>;

            <span class="hljs-keyword">if</span> (diff &lt; transparent) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
            <span class="hljs-keyword">if</span> (diff &gt; opaque) <span class="hljs-keyword">return</span> <span class="hljs-number">255</span>;
            <span class="hljs-keyword">return</span> ((diff - transparent) / range) * <span class="hljs-number">255</span>;
        };

        <span class="hljs-keyword">const</span> {<span class="hljs-attr">r</span>:inR, <span class="hljs-attr">g</span>:inG, <span class="hljs-attr">b</span>:inB, <span class="hljs-attr">a</span>:inA} = input;
        <span class="hljs-keyword">const</span> {<span class="hljs-attr">r</span>:outR, <span class="hljs-attr">g</span>:outG, <span class="hljs-attr">b</span>:outB, <span class="hljs-attr">a</span>:outA} = output;

        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) {
            outR[i] = inR[i];
            outG[i] = inG[i];
            outB[i] = inB[i];
            outA[i] = getValue(inR[i], inG[i], inB[i]);
        }

        <span class="hljs-keyword">let</span> work = <span class="hljs-built_in">this</span>.cache.work.channels;
        <span class="hljs-keyword">if</span> (lineOut) <span class="hljs-built_in">this</span>.processResults(output, work, <span class="hljs-number">1</span> - opacity);
        <span class="hljs-keyword">else</span> <span class="hljs-built_in">this</span>.processResults(work, output, opacity);
    },</pre></div></div>
            
        </li>
        
        
        <li id="section-40">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-40">&#x00a7;</a>
              </div>
              <p><strong>compose</strong> - Using two source images (from the “lineIn” and “lineMix” arguments), combine their color information using alpha compositing rules (as defined by Porter/Duff). The compositing method is determined by the String value supplied in the “compose” argument; permitted values are: ‘destination-only’, ‘destination-over’, ‘destination-in’, ‘destination-out’, ‘destination-atop’, ‘source-only’, ‘source-over’ (default), ‘source-in’, ‘source-out’, ‘source-atop’, ‘clear’, ‘xor’, or ‘lighter’. Note that the source images may be of different sizes: the output (lineOut) image size will be the same as the source (NOT lineIn) image; the lineMix image can be moved relative to the lineIn image using the “offsetX” and “offsetY” arguments.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-string">&#x27;compose&#x27;</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">requirements</span>) </span>{

        <span class="hljs-keyword">let</span> [input, output, mix] = <span class="hljs-built_in">this</span>.getInputAndOutputChannels(requirements);

        <span class="hljs-keyword">let</span> len = output.r.length;

        <span class="hljs-keyword">let</span> {opacity, compose, offsetX, offsetY, lineOut} = requirements;

        <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> == opacity) opacity = <span class="hljs-number">1</span>;
        <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> == compose) compose = <span class="hljs-string">&#x27;&#x27;</span>;
        <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> == offsetX) offsetX = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> == offsetY) offsetY = <span class="hljs-number">0</span>;

        <span class="hljs-keyword">const</span> {<span class="hljs-attr">r</span>:inR, <span class="hljs-attr">g</span>:inG, <span class="hljs-attr">b</span>:inB, <span class="hljs-attr">a</span>:inA} = input;
        <span class="hljs-keyword">const</span> {<span class="hljs-attr">r</span>:outR, <span class="hljs-attr">g</span>:outG, <span class="hljs-attr">b</span>:outB, <span class="hljs-attr">a</span>:outA} = output;
        <span class="hljs-keyword">const</span> {<span class="hljs-attr">r</span>:mixR, <span class="hljs-attr">g</span>:mixG, <span class="hljs-attr">b</span>:mixB, <span class="hljs-attr">a</span>:mixA} = mix;

        <span class="hljs-keyword">let</span> [iWidth, iHeight, oWidth, oHeight, mWidth, mHeight] = <span class="hljs-built_in">this</span>.getInputAndOutputDimensions(requirements);

        <span class="hljs-keyword">const</span> copyPixel = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">fromPos, toPos, channel</span>) </span>{

            outR[toPos] = channel.r[fromPos];
            outG[toPos] = channel.g[fromPos];
            outB[toPos] = channel.b[fromPos];
            outA[toPos] = channel.a[fromPos];
        };

        <span class="hljs-keyword">const</span> getLinePositions = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">x, y</span>) </span>{

            <span class="hljs-keyword">let</span> ix = x,
                iy = y,
                mx = x - offsetX,
                my = y - offsetY;

            <span class="hljs-keyword">let</span> mPos = -<span class="hljs-number">1</span>,
                iPos = (iy * iWidth) + ix;

            <span class="hljs-keyword">if</span> (mx &gt;= <span class="hljs-number">0</span> &amp;&amp; mx &lt; mWidth &amp;&amp; my &gt;= <span class="hljs-number">0</span> &amp;&amp; my &lt; mHeight) mPos = (my * mWidth) + mx;

            <span class="hljs-keyword">return</span> [iPos, mPos];
        };

        <span class="hljs-keyword">switch</span> (compose) {

            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;source-only&#x27;</span> :
                <span class="hljs-built_in">this</span>.copyOver(input, output);
                <span class="hljs-keyword">break</span>;

            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;source-atop&#x27;</span> :
                <span class="hljs-keyword">const</span> sAtopCalc = <span class="hljs-function">(<span class="hljs-params">iColor, iAlpha, mColor, mAlpha</span>) =&gt;</span> (iAlpha * iColor * mAlpha) + (mAlpha * mColor * (<span class="hljs-number">1</span> - iAlpha));
                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> y = <span class="hljs-number">0</span>; y &lt; iHeight; y++) {
                    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> x = <span class="hljs-number">0</span>; x &lt; iWidth; x++) {

                        <span class="hljs-keyword">let</span> [iPos, mPos] = getLinePositions(x, y);

                        <span class="hljs-keyword">if</span> (mPos &gt;= <span class="hljs-number">0</span>) {

                            <span class="hljs-keyword">let</span> dinA = inA[iPos] / <span class="hljs-number">255</span>,
                                dmixA = mixA[mPos] / <span class="hljs-number">255</span>;

                            outR[iPos] = sAtopCalc(inR[iPos], dinA, mixR[mPos], dmixA);
                            outG[iPos] = sAtopCalc(inG[iPos], dinA, mixG[mPos], dmixA);
                            outB[iPos] = sAtopCalc(inB[iPos], dinA, mixB[mPos], dmixA);
                            outA[iPos] = ((dinA * dmixA) + (dmixA * (<span class="hljs-number">1</span> - dinA))) * <span class="hljs-number">255</span>;
                        }
                    }
                }
                <span class="hljs-keyword">break</span>;

            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;source-in&#x27;</span> :
                <span class="hljs-keyword">const</span> sInCalc = <span class="hljs-function">(<span class="hljs-params">iColor, iAlpha, mAlpha</span>) =&gt;</span> iAlpha * iColor * mAlpha;
                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> y = <span class="hljs-number">0</span>; y &lt; iHeight; y++) {
                    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> x = <span class="hljs-number">0</span>; x &lt; iWidth; x++) {

                        <span class="hljs-keyword">let</span> [iPos, mPos] = getLinePositions(x, y);

                        <span class="hljs-keyword">if</span> (mPos &gt;= <span class="hljs-number">0</span>) {

                            <span class="hljs-keyword">let</span> dinA = inA[iPos] / <span class="hljs-number">255</span>,
                                dmixA = mixA[mPos] / <span class="hljs-number">255</span>;

                            outR[iPos] = sInCalc(inR[iPos], dinA, dmixA);
                            outG[iPos] = sInCalc(inG[iPos], dinA, dmixA);
                            outB[iPos] = sInCalc(inB[iPos], dinA, dmixA);
                            outA[iPos] = dinA * dmixA * <span class="hljs-number">255</span>;
                        }
                    }
                }
                <span class="hljs-keyword">break</span>;

            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;source-out&#x27;</span> :
                <span class="hljs-keyword">const</span> sOutCalc = <span class="hljs-function">(<span class="hljs-params">iColor, iAlpha, mAlpha</span>) =&gt;</span> iAlpha * iColor * (<span class="hljs-number">1</span> - mAlpha);
                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> y = <span class="hljs-number">0</span>; y &lt; iHeight; y++) {
                    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> x = <span class="hljs-number">0</span>; x &lt; iWidth; x++) {

                        <span class="hljs-keyword">let</span> [iPos, mPos] = getLinePositions(x, y);

                        <span class="hljs-keyword">if</span> (mPos &lt; <span class="hljs-number">0</span>) copyPixel(iPos, iPos, input);
                        <span class="hljs-keyword">else</span> {

                            <span class="hljs-keyword">let</span> dinA = inA[iPos] / <span class="hljs-number">255</span>,
                                dmixA = mixA[mPos] / <span class="hljs-number">255</span>;

                            outR[iPos] = sOutCalc(inR[iPos], dinA, dmixA);
                            outG[iPos] = sOutCalc(inG[iPos], dinA, dmixA);
                            outB[iPos] = sOutCalc(inB[iPos], dinA, dmixA);
                            outA[iPos] = dinA * (<span class="hljs-number">1</span> - dmixA) * <span class="hljs-number">255</span>;
                        }
                    }
                }
                <span class="hljs-keyword">break</span>;

            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;destination-only&#x27;</span> :
                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> y = <span class="hljs-number">0</span>; y &lt; iHeight; y++) {
                    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> x = <span class="hljs-number">0</span>; x &lt; iWidth; x++) {

                        <span class="hljs-keyword">let</span> [iPos, mPos] = getLinePositions(x, y);

                        <span class="hljs-keyword">if</span> (mPos &gt;= <span class="hljs-number">0</span>) copyPixel(mPos, iPos, mix);
                    }
                }
                <span class="hljs-keyword">break</span>;

            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;destination-atop&#x27;</span> :
                <span class="hljs-keyword">const</span> dAtopCalc = <span class="hljs-function">(<span class="hljs-params">iColor, iAlpha, mColor, mAlpha</span>) =&gt;</span> (iAlpha * iColor * (<span class="hljs-number">1</span> - mAlpha)) + (mAlpha * mColor * iAlpha);
                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> y = <span class="hljs-number">0</span>; y &lt; iHeight; y++) {
                    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> x = <span class="hljs-number">0</span>; x &lt; iWidth; x++) {

                        <span class="hljs-keyword">let</span> [iPos, mPos] = getLinePositions(x, y);

                        <span class="hljs-keyword">if</span> (mPos &lt; <span class="hljs-number">0</span>) copyPixel(iPos, iPos, input);
                        <span class="hljs-keyword">else</span> {

                            <span class="hljs-keyword">let</span> dinA = inA[iPos] / <span class="hljs-number">255</span>,
                                dmixA = mixA[mPos] / <span class="hljs-number">255</span>;

                            outR[iPos] = dAtopCalc(inR[iPos], dinA, mixR[mPos], dmixA);
                            outG[iPos] = dAtopCalc(inG[iPos], dinA, mixG[mPos], dmixA);
                            outB[iPos] = dAtopCalc(inB[iPos], dinA, mixB[mPos], dmixA);
                            outA[iPos] = ((dinA * (<span class="hljs-number">1</span> - dmixA)) + (dmixA * dinA)) * <span class="hljs-number">255</span>;
                        }
                    }
                }
                <span class="hljs-keyword">break</span>;

            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;destination-over&#x27;</span> :
                <span class="hljs-keyword">const</span> dOverCalc = <span class="hljs-function">(<span class="hljs-params">iColor, iAlpha, mColor, mAlpha</span>) =&gt;</span> (iAlpha * iColor * (<span class="hljs-number">1</span> - mAlpha)) + (mAlpha * mColor);
                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> y = <span class="hljs-number">0</span>; y &lt; iHeight; y++) {
                    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> x = <span class="hljs-number">0</span>; x &lt; iWidth; x++) {

                        <span class="hljs-keyword">let</span> [iPos, mPos] = getLinePositions(x, y);

                        <span class="hljs-keyword">if</span> (mPos &lt; <span class="hljs-number">0</span>) copyPixel(iPos, iPos, input);
                        <span class="hljs-keyword">else</span> {

                            <span class="hljs-keyword">let</span> dinA = inA[iPos] / <span class="hljs-number">255</span>,
                                dmixA = mixA[mPos] / <span class="hljs-number">255</span>;

                            outR[iPos] = dOverCalc(inR[iPos], dinA, mixR[mPos], dmixA);
                            outG[iPos] = dOverCalc(inG[iPos], dinA, mixG[mPos], dmixA);
                            outB[iPos] = dOverCalc(inB[iPos], dinA, mixB[mPos], dmixA);
                            outA[iPos] = ((dinA * (<span class="hljs-number">1</span> - dmixA)) + dmixA) * <span class="hljs-number">255</span>;
                        }
                    }
                }
                <span class="hljs-keyword">break</span>;

            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;destination-in&#x27;</span> :
                <span class="hljs-keyword">const</span> dInCalc = <span class="hljs-function">(<span class="hljs-params">iColor, iAlpha, mAlpha</span>) =&gt;</span> iAlpha * iColor * mAlpha;
                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> y = <span class="hljs-number">0</span>; y &lt; iHeight; y++) {
                    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> x = <span class="hljs-number">0</span>; x &lt; iWidth; x++) {

                        <span class="hljs-keyword">let</span> [iPos, mPos] = getLinePositions(x, y);

                        <span class="hljs-keyword">if</span> (mPos &gt;= <span class="hljs-number">0</span>) {

                            <span class="hljs-keyword">let</span> dinA = inA[iPos] / <span class="hljs-number">255</span>,
                                dmixA = mixA[mPos] / <span class="hljs-number">255</span>;

                            outR[iPos] = dInCalc(mixR[mPos], dmixA, dinA);
                            outG[iPos] = dInCalc(mixG[mPos], dmixA, dinA);
                            outB[iPos] = dInCalc(mixB[mPos], dmixA, dinA);
                            outA[iPos] = dinA * dmixA * <span class="hljs-number">255</span>;
                        }
                    }
                }
                <span class="hljs-keyword">break</span>;

            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;destination-out&#x27;</span> :
                <span class="hljs-keyword">const</span> dOutCalc = <span class="hljs-function">(<span class="hljs-params">mColor, iAlpha, mAlpha</span>) =&gt;</span> mAlpha * mColor * (<span class="hljs-number">1</span> - iAlpha);
                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> y = <span class="hljs-number">0</span>; y &lt; iHeight; y++) {
                    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> x = <span class="hljs-number">0</span>; x &lt; iWidth; x++) {

                        <span class="hljs-keyword">let</span> [iPos, mPos] = getLinePositions(x, y);

                        <span class="hljs-keyword">if</span> (mPos &gt;= <span class="hljs-number">0</span>) {
        
                            <span class="hljs-keyword">let</span> dinA = inA[iPos] / <span class="hljs-number">255</span>,
                                dmixA = mixA[mPos] / <span class="hljs-number">255</span>;

                            outR[iPos] = dOutCalc(mixR[mPos], dinA, dmixA);
                            outG[iPos] = dOutCalc(mixG[mPos], dinA, dmixA);
                            outB[iPos] = dOutCalc(mixB[mPos], dinA, dmixA);
                            outA[iPos] = dmixA * (<span class="hljs-number">1</span> - dinA) * <span class="hljs-number">255</span>;
                        }
                    }
                }
                <span class="hljs-keyword">break</span>;

            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;clear&#x27;</span> :
                <span class="hljs-keyword">break</span>;

            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;xor&#x27;</span> :
                <span class="hljs-keyword">const</span> xorCalc = <span class="hljs-function">(<span class="hljs-params">iColor, iAlpha, mColor, mAlpha</span>) =&gt;</span> (iAlpha * iColor * (<span class="hljs-number">1</span> - mAlpha)) + (mAlpha * mColor * (<span class="hljs-number">1</span> - iAlpha));
                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> y = <span class="hljs-number">0</span>; y &lt; iHeight; y++) {
                    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> x = <span class="hljs-number">0</span>; x &lt; iWidth; x++) {

                        <span class="hljs-keyword">let</span> [iPos, mPos] = getLinePositions(x, y);

                        <span class="hljs-keyword">if</span> (mPos &lt; <span class="hljs-number">0</span>) copyPixel(iPos, iPos, input);
                        <span class="hljs-keyword">else</span> {

                            <span class="hljs-keyword">let</span> dinA = inA[iPos] / <span class="hljs-number">255</span>,
                                dmixA = mixA[mPos] / <span class="hljs-number">255</span>;

                            outR[iPos] = xorCalc(inR[iPos], dinA, mixR[mPos], dmixA);
                            outG[iPos] = xorCalc(inG[iPos], dinA, mixG[mPos], dmixA);
                            outB[iPos] = xorCalc(inB[iPos], dinA, mixB[mPos], dmixA);
                            outA[iPos] = ((dinA * (<span class="hljs-number">1</span> - dmixA)) + (dmixA * (<span class="hljs-number">1</span> - dinA))) * <span class="hljs-number">255</span>;
                        }
                    }
                }
                <span class="hljs-keyword">break</span>;

            <span class="hljs-keyword">default</span>:
                <span class="hljs-keyword">const</span> sOverCalc = <span class="hljs-function">(<span class="hljs-params">iColor, iAlpha, mColor, mAlpha</span>) =&gt;</span> (iAlpha * iColor) + (mAlpha * mColor * (<span class="hljs-number">1</span> - iAlpha));
                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> y = <span class="hljs-number">0</span>; y &lt; iHeight; y++) {
                    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> x = <span class="hljs-number">0</span>; x &lt; iWidth; x++) {

                        <span class="hljs-keyword">let</span> [iPos, mPos] = getLinePositions(x, y);

                        <span class="hljs-keyword">if</span> (mPos &lt; <span class="hljs-number">0</span>) copyPixel(iPos, iPos, input);
                        <span class="hljs-keyword">else</span> {

                            <span class="hljs-keyword">let</span> dinA = inA[iPos] / <span class="hljs-number">255</span>,
                                dmixA = mixA[mPos] / <span class="hljs-number">255</span>;

                            outR[iPos] = sOverCalc(inR[iPos], dinA, mixR[mPos], dmixA);
                            outG[iPos] = sOverCalc(inG[iPos], dinA, mixG[mPos], dmixA);
                            outB[iPos] = sOverCalc(inB[iPos], dinA, mixB[mPos], dmixA);
                            outA[iPos] = (dinA + (dmixA * (<span class="hljs-number">1</span> - dinA))) * <span class="hljs-number">255</span>;
                        }
                    }
                }
        }
        <span class="hljs-keyword">let</span> work = <span class="hljs-built_in">this</span>.cache.work.channels;
        <span class="hljs-keyword">if</span> (lineOut) <span class="hljs-built_in">this</span>.processResults(output, work, <span class="hljs-number">1</span> - opacity);
        <span class="hljs-keyword">else</span> <span class="hljs-built_in">this</span>.processResults(work, output, opacity);
    },</pre></div></div>
            
        </li>
        
        
        <li id="section-41">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-41">&#x00a7;</a>
              </div>
              <p><strong>displace</strong> - Shift pixels around the image, based on the values supplied in a displacement image</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-string">&#x27;displace&#x27;</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">requirements</span>) </span>{

        <span class="hljs-keyword">let</span> [input, output, mix] = <span class="hljs-built_in">this</span>.getInputAndOutputChannels(requirements);

        <span class="hljs-keyword">let</span> len = input.r.length;

        <span class="hljs-keyword">let</span> {opacity, channelX, channelY, scaleX, scaleY, offsetX, offsetY, transparentEdges, lineOut} = requirements;

        <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> == opacity) opacity = <span class="hljs-number">1</span>;
        <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> == channelX) channelX = <span class="hljs-string">&#x27;red&#x27;</span>;
        <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> == channelY) channelY = <span class="hljs-string">&#x27;green&#x27;</span>;
        <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> == scaleX) scaleX = <span class="hljs-number">1</span>;
        <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> == scaleY) scaleY = <span class="hljs-number">1</span>;
        <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> == offsetX) offsetX = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> == offsetY) offsetY = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> == transparentEdges) transparentEdges = <span class="hljs-literal">false</span>;

        <span class="hljs-keyword">const</span> {<span class="hljs-attr">r</span>:inR, <span class="hljs-attr">g</span>:inG, <span class="hljs-attr">b</span>:inB, <span class="hljs-attr">a</span>:inA} = input;
        <span class="hljs-keyword">const</span> {<span class="hljs-attr">r</span>:outR, <span class="hljs-attr">g</span>:outG, <span class="hljs-attr">b</span>:outB, <span class="hljs-attr">a</span>:outA} = output;
        <span class="hljs-keyword">const</span> {<span class="hljs-attr">r</span>:mixR, <span class="hljs-attr">g</span>:mixG, <span class="hljs-attr">b</span>:mixB, <span class="hljs-attr">a</span>:mixA} = mix;

        <span class="hljs-keyword">if</span> (channelX == <span class="hljs-string">&#x27;red&#x27;</span>) channelX = mixR;
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (channelX == <span class="hljs-string">&#x27;green&#x27;</span>) channelX = mixG;
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (channelX == <span class="hljs-string">&#x27;blue&#x27;</span>) channelX = mixB;
        <span class="hljs-keyword">else</span> channelX = mixA;

        <span class="hljs-keyword">if</span> (channelY == <span class="hljs-string">&#x27;red&#x27;</span>) channelY = mixR;
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (channelY == <span class="hljs-string">&#x27;green&#x27;</span>) channelY = mixG;
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (channelY == <span class="hljs-string">&#x27;blue&#x27;</span>) channelY = mixB;
        <span class="hljs-keyword">else</span> channelY = mixA;

        <span class="hljs-keyword">let</span> [iWidth, iHeight, oWidth, oHeight, mWidth, mHeight] = <span class="hljs-built_in">this</span>.getInputAndOutputDimensions(requirements);

        <span class="hljs-keyword">const</span> copyPixel = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">fromPos, toPos, channel</span>) </span>{

            <span class="hljs-keyword">if</span> (fromPos &lt; <span class="hljs-number">0</span>) outA[toPos] = <span class="hljs-number">0</span>;
            <span class="hljs-keyword">else</span> {

                outR[toPos] = channel.r[fromPos];
                outG[toPos] = channel.g[fromPos];
                outB[toPos] = channel.b[fromPos];
                outA[toPos] = channel.a[fromPos];
            }
        };

        <span class="hljs-keyword">const</span> getLinePositions = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">x, y</span>) </span>{

            <span class="hljs-keyword">let</span> ix = x,
                iy = y,
                mx = x + offsetX,
                my = y + offsetY;

            <span class="hljs-keyword">let</span> mPos = -<span class="hljs-number">1</span>,
                iPos = (iy * iWidth) + ix;

            <span class="hljs-keyword">if</span> (mx &gt;= <span class="hljs-number">0</span> &amp;&amp; mx &lt; mWidth &amp;&amp; my &gt;= <span class="hljs-number">0</span> &amp;&amp; my &lt; mHeight) mPos = (my * mWidth) + mx;

            <span class="hljs-keyword">return</span> [iPos, mPos];
        };

        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> y = <span class="hljs-number">0</span>; y &lt; iHeight; y++) {
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> x = <span class="hljs-number">0</span>; x &lt; iWidth; x++) {

                <span class="hljs-keyword">let</span> [iPos, mPos] = getLinePositions(x, y);

                <span class="hljs-keyword">if</span> (mPos &gt;= <span class="hljs-number">0</span>) {

                    <span class="hljs-keyword">let</span> dx = <span class="hljs-built_in">Math</span>.floor(x + ((<span class="hljs-number">127</span> - channelX[mPos]) / <span class="hljs-number">127</span>) * scaleX);
                    <span class="hljs-keyword">let</span> dy = <span class="hljs-built_in">Math</span>.floor(y + ((<span class="hljs-number">127</span> - channelY[mPos]) / <span class="hljs-number">127</span>) * scaleY);
                    <span class="hljs-keyword">let</span> dPos;

                    <span class="hljs-keyword">if</span> (!transparentEdges) {

                        <span class="hljs-keyword">if</span> (dx &lt; <span class="hljs-number">0</span>) dx = <span class="hljs-number">0</span>;
                        <span class="hljs-keyword">if</span> (dx &gt;= iWidth) dx = iWidth - <span class="hljs-number">1</span>;
                        <span class="hljs-keyword">if</span> (dy &lt; <span class="hljs-number">0</span>) dy = <span class="hljs-number">0</span>;
                        <span class="hljs-keyword">if</span> (dy &gt;= iHeight) dy = iHeight - <span class="hljs-number">1</span>;

                        dPos = (dy * iWidth) + dx;
                    }
                    <span class="hljs-keyword">else</span> {

                        <span class="hljs-keyword">if</span> (dx &lt; <span class="hljs-number">0</span> || dx &gt;= iWidth || dy &lt; <span class="hljs-number">0</span> || dy &gt;= iHeight) dPos = -<span class="hljs-number">1</span>;
                        <span class="hljs-keyword">else</span> dPos = (dy * iWidth) + dx;
                    }

                    copyPixel(dPos, iPos, input);
                }
                <span class="hljs-keyword">else</span> copyPixel(iPos, iPos, input);
            }
        }
        <span class="hljs-keyword">let</span> work = <span class="hljs-built_in">this</span>.cache.work.channels;
        <span class="hljs-keyword">if</span> (lineOut) <span class="hljs-built_in">this</span>.processResults(output, work, <span class="hljs-number">1</span> - opacity);
        <span class="hljs-keyword">else</span> <span class="hljs-built_in">this</span>.processResults(work, output, opacity);
    },</pre></div></div>
            
        </li>
        
        
        <li id="section-42">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-42">&#x00a7;</a>
              </div>
              <p><strong>emboss</strong> - A 3x3 matrix transform; the matrix weights are calculated internally from the values of two arguments: “strength”, and “angle” - which is a value measured in degrees, with 0 degrees pointing to the right of the origin (along the positive x axis). Post-processing options include removing unchanged pixels, or setting then to mid-gray. The convenience method includes additional arguments which will add a choice of grayscale, then channel clamping, then blurring actions before passing the results to this emboss action</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-string">&#x27;emboss&#x27;</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">requirements</span>) </span>{

        <span class="hljs-keyword">let</span> [input, output] = <span class="hljs-built_in">this</span>.getInputAndOutputChannels(requirements);

        <span class="hljs-keyword">let</span> len = input.r.length;

        <span class="hljs-keyword">let</span> {opacity, strength, angle, tolerance, keepOnlyChangedAreas, postProcessResults, lineOut} = requirements;

        <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> == opacity) opacity = <span class="hljs-number">1</span>;
        <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> == strength) strength = <span class="hljs-number">1</span>;
        <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> == angle) angle = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> == tolerance) tolerance = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> == keepOnlyChangedAreas) keepOnlyChangedAreas = <span class="hljs-literal">false</span>;
        <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> == postProcessResults) postProcessResults = <span class="hljs-literal">false</span>;

        strength = <span class="hljs-built_in">Math</span>.abs(strength);

        <span class="hljs-keyword">while</span> (angle &lt; <span class="hljs-number">0</span>) {
            angle += <span class="hljs-number">360</span>;
        }

        angle = angle % <span class="hljs-number">360</span>;

        <span class="hljs-keyword">let</span> slices = <span class="hljs-built_in">Math</span>.floor(angle / <span class="hljs-number">45</span>),
            remains = ((angle % <span class="hljs-number">45</span>) / <span class="hljs-number">45</span>) * strength,
            weights = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(<span class="hljs-number">9</span>);

        weights = weights.fill(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">9</span>); 
        weights[<span class="hljs-number">4</span>] = <span class="hljs-number">1</span>;

        <span class="hljs-keyword">if</span> (slices == <span class="hljs-number">0</span>) {
            weights[<span class="hljs-number">5</span>] = strength - remains;
            weights[<span class="hljs-number">8</span>] = remains;
            weights[<span class="hljs-number">3</span>] = -weights[<span class="hljs-number">5</span>];
            weights[<span class="hljs-number">0</span>] = -weights[<span class="hljs-number">8</span>];
        }
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (slices == <span class="hljs-number">1</span>) {
            weights[<span class="hljs-number">8</span>] = strength - remains;
            weights[<span class="hljs-number">7</span>] = remains;
            weights[<span class="hljs-number">0</span>] = -weights[<span class="hljs-number">8</span>];
            weights[<span class="hljs-number">1</span>] = -weights[<span class="hljs-number">7</span>];
        }
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (slices == <span class="hljs-number">2</span>) {
            weights[<span class="hljs-number">7</span>] = strength - remains;
            weights[<span class="hljs-number">6</span>] = remains;
            weights[<span class="hljs-number">1</span>] = -weights[<span class="hljs-number">7</span>];
            weights[<span class="hljs-number">2</span>] = -weights[<span class="hljs-number">6</span>];
        }
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (slices == <span class="hljs-number">3</span>) {
            weights[<span class="hljs-number">6</span>] = strength - remains;
            weights[<span class="hljs-number">3</span>] = remains;
            weights[<span class="hljs-number">2</span>] = -weights[<span class="hljs-number">6</span>];
            weights[<span class="hljs-number">5</span>] = -weights[<span class="hljs-number">3</span>];
        }
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (slices == <span class="hljs-number">4</span>) {
            weights[<span class="hljs-number">3</span>] = strength - remains;
            weights[<span class="hljs-number">0</span>] = remains;
            weights[<span class="hljs-number">5</span>] = -weights[<span class="hljs-number">3</span>];
            weights[<span class="hljs-number">8</span>] = -weights[<span class="hljs-number">0</span>];
        }
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (slices == <span class="hljs-number">5</span>) {
            weights[<span class="hljs-number">0</span>] = strength - remains;
            weights[<span class="hljs-number">1</span>] = remains;
            weights[<span class="hljs-number">8</span>] = -weights[<span class="hljs-number">0</span>];
            weights[<span class="hljs-number">7</span>] = -weights[<span class="hljs-number">1</span>];
        }
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (slices == <span class="hljs-number">6</span>) {
            weights[<span class="hljs-number">1</span>] = strength - remains;
            weights[<span class="hljs-number">2</span>] = remains;
            weights[<span class="hljs-number">7</span>] = -weights[<span class="hljs-number">1</span>];
            weights[<span class="hljs-number">6</span>] = -weights[<span class="hljs-number">2</span>];
        }
        <span class="hljs-keyword">else</span> {
            weights[<span class="hljs-number">2</span>] = strength - remains;
            weights[<span class="hljs-number">5</span>] = remains;
            weights[<span class="hljs-number">6</span>] = -weights[<span class="hljs-number">2</span>];
            weights[<span class="hljs-number">3</span>] = -weights[<span class="hljs-number">5</span>];
        }

        <span class="hljs-keyword">const</span> {<span class="hljs-attr">r</span>:inR, <span class="hljs-attr">g</span>:inG, <span class="hljs-attr">b</span>:inB, <span class="hljs-attr">a</span>:inA} = input;
        <span class="hljs-keyword">const</span> {<span class="hljs-attr">r</span>:outR, <span class="hljs-attr">g</span>:outG, <span class="hljs-attr">b</span>:outB, <span class="hljs-attr">a</span>:outA} = output;

        <span class="hljs-keyword">const</span> grid = <span class="hljs-built_in">this</span>.buildMatrixGrid(<span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, inA);

        <span class="hljs-keyword">const</span> doCalculations = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">inChannel, matrix</span>) </span>{

            <span class="hljs-keyword">let</span> val = <span class="hljs-number">0</span>;

            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> m = <span class="hljs-number">0</span>, mz = matrix.length; m &lt; mz; m++) {

                <span class="hljs-keyword">if</span> (weights[m]) val += (inChannel[matrix[m]] * weights[m]);
            }
            <span class="hljs-keyword">return</span> val;
        }

        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) {

            <span class="hljs-keyword">if</span> (inA[i]) {

                outR[i] = doCalculations(inR, grid[i]);
                outG[i] = doCalculations(inG, grid[i]);
                outB[i] = doCalculations(inB, grid[i]);
                outA[i] = inA[i];

                <span class="hljs-keyword">if</span> (postProcessResults) {

                    <span class="hljs-keyword">if</span> (outR[i] &gt;= inR[i] - tolerance &amp;&amp; outR[i] &lt;= inR[i] + tolerance &amp;&amp; 
                        outG[i] &gt;= inG[i] - tolerance &amp;&amp; outG[i] &lt;= inG[i] + tolerance &amp;&amp; 
                        outB[i] &gt;= inB[i] - tolerance &amp;&amp; outB[i] &lt;= inB[i] + tolerance) {

                        <span class="hljs-keyword">if</span> (keepOnlyChangedAreas) outA[i] = <span class="hljs-number">0</span>;
                        <span class="hljs-keyword">else</span> {
                            outR[i] = <span class="hljs-number">127</span>;
                            outG[i] = <span class="hljs-number">127</span>;
                            outB[i] = <span class="hljs-number">127</span>;
                        }
                    }
                }
            }
        }
        <span class="hljs-keyword">let</span> work = <span class="hljs-built_in">this</span>.cache.work.channels;
        <span class="hljs-keyword">if</span> (lineOut) <span class="hljs-built_in">this</span>.processResults(output, work, <span class="hljs-number">1</span> - opacity);
        <span class="hljs-keyword">else</span> <span class="hljs-built_in">this</span>.processResults(work, output, opacity);
    },</pre></div></div>
            
        </li>
        
        
        <li id="section-43">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-43">&#x00a7;</a>
              </div>
              <p><strong>flood</strong> - Set all pixels to the channel values supplied in the “red”, “green”, “blue” and “alpha” arguments</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-string">&#x27;flood&#x27;</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">requirements</span>) </span>{

        <span class="hljs-keyword">let</span> [input, output] = <span class="hljs-built_in">this</span>.getInputAndOutputChannels(requirements);

        <span class="hljs-keyword">let</span> len = input.r.length,
            floor = <span class="hljs-built_in">Math</span>.floor;

        <span class="hljs-keyword">let</span> {opacity, red, green, blue, alpha, lineOut} = requirements;

        <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> == opacity) opacity = <span class="hljs-number">1</span>;
        <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> == red) red = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> == green) green = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> == blue) blue = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> == alpha) alpha = <span class="hljs-number">255</span>;

        <span class="hljs-keyword">const</span> {<span class="hljs-attr">r</span>:outR, <span class="hljs-attr">g</span>:outG, <span class="hljs-attr">b</span>:outB, <span class="hljs-attr">a</span>:outA} = output;

        outR.fill(red, <span class="hljs-number">0</span>, len - <span class="hljs-number">1</span>);
        outG.fill(green, <span class="hljs-number">0</span>, len - <span class="hljs-number">1</span>);
        outB.fill(blue, <span class="hljs-number">0</span>, len - <span class="hljs-number">1</span>);
        outA.fill(alpha, <span class="hljs-number">0</span>, len - <span class="hljs-number">1</span>);

        <span class="hljs-keyword">let</span> work = <span class="hljs-built_in">this</span>.cache.work.channels;
        <span class="hljs-keyword">if</span> (lineOut) <span class="hljs-built_in">this</span>.processResults(output, work, <span class="hljs-number">1</span> - opacity);
        <span class="hljs-keyword">else</span> <span class="hljs-built_in">this</span>.processResults(work, output, opacity);
    },</pre></div></div>
            
        </li>
        
        
        <li id="section-44">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-44">&#x00a7;</a>
              </div>
              <p><strong>grayscale</strong> - For each pixel, averages the weighted color channels and applies the result across all the color channels. This gives a more realistic monochrome effect.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-string">&#x27;grayscale&#x27;</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">requirements</span>) </span>{

        <span class="hljs-keyword">let</span> [input, output] = <span class="hljs-built_in">this</span>.getInputAndOutputChannels(requirements);

        <span class="hljs-keyword">let</span> len = input.r.length;

        <span class="hljs-keyword">let</span> {opacity, lineOut} = requirements;

        <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> == opacity) opacity = <span class="hljs-number">1</span>;

        <span class="hljs-keyword">const</span> {<span class="hljs-attr">r</span>:inR, <span class="hljs-attr">g</span>:inG, <span class="hljs-attr">b</span>:inB, <span class="hljs-attr">a</span>:inA} = input;
        <span class="hljs-keyword">const</span> {<span class="hljs-attr">r</span>:outR, <span class="hljs-attr">g</span>:outG, <span class="hljs-attr">b</span>:outB, <span class="hljs-attr">a</span>:outA} = output;

        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) {

            <span class="hljs-keyword">let</span> gray = <span class="hljs-built_in">Math</span>.floor((<span class="hljs-number">0.2126</span> * inR[i]) + (<span class="hljs-number">0.7152</span> * inG[i]) + (<span class="hljs-number">0.0722</span> * inB[i]));

            outR[i] = gray;
            outG[i] = gray;
            outB[i] = gray;
            outA[i] = inA[i];
        }

        <span class="hljs-keyword">let</span> work = <span class="hljs-built_in">this</span>.cache.work.channels;
        <span class="hljs-keyword">if</span> (lineOut) <span class="hljs-built_in">this</span>.processResults(output, work, <span class="hljs-number">1</span> - opacity);
        <span class="hljs-keyword">else</span> <span class="hljs-built_in">this</span>.processResults(work, output, opacity);
    },</pre></div></div>
            
        </li>
        
        
        <li id="section-45">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-45">&#x00a7;</a>
              </div>
              <p><strong>invert-channels</strong> - For each pixel, subtracts its current channel values - when included - from 255.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-string">&#x27;invert-channels&#x27;</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">requirements</span>) </span>{

        <span class="hljs-keyword">let</span> [input, output] = <span class="hljs-built_in">this</span>.getInputAndOutputChannels(requirements);

        <span class="hljs-keyword">let</span> len = input.r.length;

        <span class="hljs-keyword">let</span> {opacity, includeRed, includeGreen, includeBlue, includeAlpha, lineOut} = requirements;

        <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> == opacity) opacity = <span class="hljs-number">1</span>;
        <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> == includeRed) includeRed = <span class="hljs-literal">true</span>;
        <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> == includeGreen) includeGreen = <span class="hljs-literal">true</span>;
        <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> == includeBlue) includeBlue = <span class="hljs-literal">true</span>;
        <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> == includeAlpha) includeAlpha = <span class="hljs-literal">false</span>;

        <span class="hljs-keyword">const</span> {<span class="hljs-attr">r</span>:inR, <span class="hljs-attr">g</span>:inG, <span class="hljs-attr">b</span>:inB, <span class="hljs-attr">a</span>:inA} = input;
        <span class="hljs-keyword">const</span> {<span class="hljs-attr">r</span>:outR, <span class="hljs-attr">g</span>:outG, <span class="hljs-attr">b</span>:outB, <span class="hljs-attr">a</span>:outA} = output;

        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) {

            outR[i] = (includeRed) ? <span class="hljs-number">255</span> - inR[i] : inR[i];
            outG[i] = (includeGreen) ? <span class="hljs-number">255</span> - inG[i] : inG[i];
            outB[i] = (includeBlue) ? <span class="hljs-number">255</span> - inB[i] : inB[i];
            outA[i] = (includeAlpha) ? <span class="hljs-number">255</span> - inA[i] : inA[i];
        }
        <span class="hljs-keyword">let</span> work = <span class="hljs-built_in">this</span>.cache.work.channels;
        <span class="hljs-keyword">if</span> (lineOut) <span class="hljs-built_in">this</span>.processResults(output, work, <span class="hljs-number">1</span> - opacity);
        <span class="hljs-keyword">else</span> <span class="hljs-built_in">this</span>.processResults(work, output, opacity);
    },</pre></div></div>
            
        </li>
        
        
        <li id="section-46">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-46">&#x00a7;</a>
              </div>
              <p><strong>lock-channels-to-levels</strong> - Produces a posterize effect. Takes in four arguments - “red”, “green”, “blue” and “alpha” - each of which is an Array of zero or more integer Numbers (between 0 and 255). The filter works by looking at each pixel’s channel value and determines which of the corresponding Array’s Number values it is closest to; it then sets the channel value to that Number value.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-string">&#x27;lock-channels-to-levels&#x27;</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">requirements</span>) </span>{

        <span class="hljs-built_in">this</span>.checkChannelLevelsParameters(requirements)

        <span class="hljs-keyword">const</span> getValue = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">val, levels</span>) </span>{

            <span class="hljs-keyword">if</span> (!levels.length) <span class="hljs-keyword">return</span> val;

            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>, iz = levels.length; i &lt; iz; i++) {

                <span class="hljs-keyword">let</span> [start, end, level] = levels[i];
                <span class="hljs-keyword">if</span> (val &gt;= start &amp;&amp; val &lt;= end) <span class="hljs-keyword">return</span> level;
            }
        };

        <span class="hljs-keyword">let</span> [input, output] = <span class="hljs-built_in">this</span>.getInputAndOutputChannels(requirements);

        <span class="hljs-keyword">let</span> len = input.r.length;

        <span class="hljs-keyword">let</span> {opacity, red, green, blue, alpha, lineOut} = requirements;

        <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> == opacity) opacity = <span class="hljs-number">1</span>;
        <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> == red) red = [<span class="hljs-number">0</span>];
        <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> == green) green = [<span class="hljs-number">0</span>];
        <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> == blue) blue = [<span class="hljs-number">0</span>];
        <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> == alpha) alpha = [<span class="hljs-number">255</span>];

        <span class="hljs-keyword">const</span> {<span class="hljs-attr">r</span>:inR, <span class="hljs-attr">g</span>:inG, <span class="hljs-attr">b</span>:inB, <span class="hljs-attr">a</span>:inA} = input;
        <span class="hljs-keyword">const</span> {<span class="hljs-attr">r</span>:outR, <span class="hljs-attr">g</span>:outG, <span class="hljs-attr">b</span>:outB, <span class="hljs-attr">a</span>:outA} = output;

        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) {
            outR[i] = getValue(inR[i], red);
            outG[i] = getValue(inG[i], green);
            outB[i] = getValue(inB[i], blue);
            outA[i] = getValue(inA[i], alpha);
        }

        <span class="hljs-keyword">let</span> work = <span class="hljs-built_in">this</span>.cache.work.channels;
        <span class="hljs-keyword">if</span> (lineOut) <span class="hljs-built_in">this</span>.processResults(output, work, <span class="hljs-number">1</span> - opacity);
        <span class="hljs-keyword">else</span> <span class="hljs-built_in">this</span>.processResults(work, output, opacity);
    },</pre></div></div>
            
        </li>
        
        
        <li id="section-47">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-47">&#x00a7;</a>
              </div>
              <p><strong>matrix</strong> - Performs a matrix operation on each pixel’s channels, calculating the new value using neighbouring pixel weighted values. Also known as a convolution matrix, kernel or mask operation. Note that this filter is expensive, thus much slower to complete compared to other filter effects. The matrix dimensions can be set using the “width” and “height” arguments, while setting the home pixel’s position within the matrix can be set using the “offsetX” and “offsetY” arguments. The weights to be applied need to be supplied in the “weights” argument - an Array listing the weights row-by-row starting from the top-left corner of the matrix. By default all color channels are included in the calculations while the alpha channel is excluded. The ‘edgeDetect’, ‘emboss’ and ‘sharpen’ convenience filter methods all use the matrix action, pre-setting the required weights.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-string">&#x27;matrix&#x27;</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">requirements</span>) </span>{

        <span class="hljs-keyword">let</span> [input, output] = <span class="hljs-built_in">this</span>.getInputAndOutputChannels(requirements);

        <span class="hljs-keyword">let</span> len = input.r.length;

        <span class="hljs-keyword">let</span> {opacity, includeRed, includeGreen, includeBlue, includeAlpha, width, height, offsetX, offsetY, weights, lineOut} = requirements;

        <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> == opacity) opacity = <span class="hljs-number">1</span>;
        <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> == includeRed) includeRed = <span class="hljs-literal">true</span>;
        <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> == includeGreen) includeGreen = <span class="hljs-literal">true</span>;
        <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> == includeBlue) includeBlue = <span class="hljs-literal">true</span>;
        <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> == includeAlpha) includeAlpha = <span class="hljs-literal">false</span>;
        <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> == width || width &lt; <span class="hljs-number">1</span>) width = <span class="hljs-number">3</span>;
        <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> == height || height &lt; <span class="hljs-number">1</span>) height = <span class="hljs-number">3</span>;
        <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> == offsetX) offsetX = <span class="hljs-number">1</span>;
        <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> == offsetY) offsetY = <span class="hljs-number">1</span>;
        <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> == weights) {
            weights = [].fill(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, (width * height) - <span class="hljs-number">1</span>);
            weights[<span class="hljs-built_in">Math</span>.floor(weights.length / <span class="hljs-number">2</span>) + <span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;
        }

        <span class="hljs-keyword">let</span> grid = <span class="hljs-built_in">this</span>.buildMatrixGrid(width, height, offsetX, offsetY, input.a);

        <span class="hljs-keyword">const</span> doCalculations = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">inChannel, matrix</span>) </span>{

            <span class="hljs-keyword">let</span> val = <span class="hljs-number">0</span>;

            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> m = <span class="hljs-number">0</span>, mz = matrix.length; m &lt; mz; m++) {

                <span class="hljs-keyword">if</span> (weights[m]) val += (inChannel[matrix[m]] * weights[m]);
            }
            <span class="hljs-keyword">return</span> val;
        }

        <span class="hljs-keyword">const</span> {<span class="hljs-attr">r</span>:inR, <span class="hljs-attr">g</span>:inG, <span class="hljs-attr">b</span>:inB, <span class="hljs-attr">a</span>:inA} = input;
        <span class="hljs-keyword">const</span> {<span class="hljs-attr">r</span>:outR, <span class="hljs-attr">g</span>:outG, <span class="hljs-attr">b</span>:outB, <span class="hljs-attr">a</span>:outA} = output;

        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) {

            <span class="hljs-keyword">if</span> (inA[i]) {

                <span class="hljs-keyword">if</span> (includeRed) outR[i] = doCalculations(inR, grid[i]);
                <span class="hljs-keyword">else</span> outR[i] = inR[i];

                <span class="hljs-keyword">if</span> (includeGreen) outG[i] = doCalculations(inG, grid[i]);
                <span class="hljs-keyword">else</span> outG[i] = inG[i];

                <span class="hljs-keyword">if</span> (includeBlue) outB[i] = doCalculations(inB, grid[i]);
                <span class="hljs-keyword">else</span> outB[i] = inB[i];

                <span class="hljs-keyword">if</span> (includeAlpha) outA[i] = doCalculations(inA, grid[i]);
                <span class="hljs-keyword">else</span> outA[i] = inA[i];
            }
        }
        <span class="hljs-keyword">let</span> work = <span class="hljs-built_in">this</span>.cache.work.channels;
        <span class="hljs-keyword">if</span> (lineOut) <span class="hljs-built_in">this</span>.processResults(output, work, <span class="hljs-number">1</span> - opacity);
        <span class="hljs-keyword">else</span> <span class="hljs-built_in">this</span>.processResults(work, output, opacity);
    },</pre></div></div>
            
        </li>
        
        
        <li id="section-48">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-48">&#x00a7;</a>
              </div>
              <p><strong>modulate-channels</strong> - Multiplies each channel’s value by the supplied argument value. A channel-argument’s value of ‘0’ will set that channel’s value to zero; a value of ‘1’ will leave the channel value unchanged. If the “saturation” flag is set to ‘true’ the calculation changes to start at the color range mid point. The ‘brightness’ and ‘saturation’ filters are special forms of the ‘channels’ filter which use a single “levels” argument to set all three color channel arguments to the same value.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-string">&#x27;modulate-channels&#x27;</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">requirements</span>) </span>{

        <span class="hljs-keyword">let</span> [input, output] = <span class="hljs-built_in">this</span>.getInputAndOutputChannels(requirements);

        <span class="hljs-keyword">let</span> len = input.r.length;

        <span class="hljs-keyword">let</span> {opacity, red, green, blue, alpha, saturation, lineOut} = requirements;

        <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> == opacity) opacity = <span class="hljs-number">1</span>;
        <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> == red) red = <span class="hljs-number">1</span>;
        <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> == green) green = <span class="hljs-number">1</span>;
        <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> == blue) blue = <span class="hljs-number">1</span>;
        <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> == alpha) alpha = <span class="hljs-number">1</span>;
        <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> == saturation) saturation = <span class="hljs-literal">false</span>;

        <span class="hljs-keyword">const</span> {<span class="hljs-attr">r</span>:inR, <span class="hljs-attr">g</span>:inG, <span class="hljs-attr">b</span>:inB, <span class="hljs-attr">a</span>:inA} = input;
        <span class="hljs-keyword">const</span> {<span class="hljs-attr">r</span>:outR, <span class="hljs-attr">g</span>:outG, <span class="hljs-attr">b</span>:outB, <span class="hljs-attr">a</span>:outA} = output;

        <span class="hljs-keyword">if</span> (saturation) {

            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) {
                outR[i] = <span class="hljs-number">127</span> + ((inR[i] - <span class="hljs-number">127</span>) * red);
                outG[i] = <span class="hljs-number">127</span> + ((inG[i] - <span class="hljs-number">127</span>) * green);
                outB[i] = <span class="hljs-number">127</span> + ((inB[i] - <span class="hljs-number">127</span>) * blue);
                outA[i] = <span class="hljs-number">127</span> + ((inA[i] - <span class="hljs-number">127</span>) * alpha);
            }
        }
        <span class="hljs-keyword">else</span> {

            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) {
                outR[i] = inR[i] * red;
                outG[i] = inG[i] * green;
                outB[i] = inB[i] * blue;
                outA[i] = inA[i] * alpha;
            }
        }
        <span class="hljs-keyword">let</span> work = <span class="hljs-built_in">this</span>.cache.work.channels;
        <span class="hljs-keyword">if</span> (lineOut) <span class="hljs-built_in">this</span>.processResults(output, work, <span class="hljs-number">1</span> - opacity);
        <span class="hljs-keyword">else</span> <span class="hljs-built_in">this</span>.processResults(work, output, opacity);
    },</pre></div></div>
            
        </li>
        
        
        <li id="section-49">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-49">&#x00a7;</a>
              </div>
              <p><strong>offset</strong> - Offset the input image in the output image.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-string">&#x27;offset&#x27;</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">requirements</span>) </span>{

        <span class="hljs-keyword">let</span> [input, output] = <span class="hljs-built_in">this</span>.getInputAndOutputChannels(requirements);

        <span class="hljs-keyword">let</span> {opacity, offsetRedX, offsetRedY, offsetGreenX, offsetGreenY, offsetBlueX, offsetBlueY, offsetAlphaX, offsetAlphaY, lineOut} = requirements;

        <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> == opacity) opacity = <span class="hljs-number">1</span>;
        <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> == offsetRedX) offsetRedX = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> == offsetRedY) offsetRedY = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> == offsetGreenX) offsetGreenX = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> == offsetGreenY) offsetGreenY = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> == offsetBlueX) offsetBlueX = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> == offsetBlueY) offsetBlueY = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> == offsetAlphaX) offsetAlphaX = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> == offsetAlphaY) offsetAlphaY = <span class="hljs-number">0</span>;

        <span class="hljs-keyword">let</span> simpleoffset = <span class="hljs-literal">false</span>;

        <span class="hljs-keyword">if</span> (offsetRedX == offsetGreenX &amp;&amp; offsetRedX == offsetBlueX &amp;&amp; offsetRedX == offsetAlphaX &amp;&amp; offsetRedY == offsetGreenY &amp;&amp; offsetRedY == offsetBlueY &amp;&amp; offsetRedY == offsetAlphaY) simpleoffset = <span class="hljs-literal">true</span>;

        <span class="hljs-keyword">const</span> {<span class="hljs-attr">r</span>:inR, <span class="hljs-attr">g</span>:inG, <span class="hljs-attr">b</span>:inB, <span class="hljs-attr">a</span>:inA} = input;
        <span class="hljs-keyword">const</span> {<span class="hljs-attr">r</span>:outR, <span class="hljs-attr">g</span>:outG, <span class="hljs-attr">b</span>:outB, <span class="hljs-attr">a</span>:outA} = output;

        <span class="hljs-keyword">let</span> grid = <span class="hljs-built_in">this</span>.buildImageGrid(),
            gWidth = grid[<span class="hljs-number">0</span>].length,
            gHeight = grid.length,
            drx, dry, dgx, dgy, dbx, dby, dax, day, inCell, outCell;

        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> y = <span class="hljs-number">0</span>; y &lt; gHeight; y++) {
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> x = <span class="hljs-number">0</span>; x &lt; gWidth; x++) {

                inCell = grid[y][x];

                <span class="hljs-keyword">if</span> (inA[inCell]) {

                    <span class="hljs-keyword">if</span> (simpleoffset) {

                        drx = x + offsetRedX;
                        dry = y + offsetRedY;

                        <span class="hljs-keyword">if</span> (drx &gt;= <span class="hljs-number">0</span> &amp;&amp; drx &lt; gWidth &amp;&amp; dry &gt;= <span class="hljs-number">0</span> &amp;&amp; dry &lt; gHeight) {

                            outCell = grid[dry][drx];
                            outR[outCell] = inR[inCell];
                            outG[outCell] = inG[inCell];
                            outB[outCell] = inB[inCell];
                            outA[outCell] = inA[inCell];
                        }
                    }
                    <span class="hljs-keyword">else</span> {

                        drx = x + offsetRedX;
                        dry = y + offsetRedY;
                        dgx = x + offsetGreenX;
                        dgy = y + offsetGreenY;
                        dbx = x + offsetBlueX;
                        dby = y + offsetBlueY;
                        dax = x + offsetAlphaX;
                        day = y + offsetAlphaY;

                        <span class="hljs-keyword">if</span> (drx &gt;= <span class="hljs-number">0</span> &amp;&amp; drx &lt; gWidth &amp;&amp; dry &gt;= <span class="hljs-number">0</span> &amp;&amp; dry &lt; gHeight) {

                            outCell = grid[dry][drx];
                            outR[outCell] = inR[inCell];
                        }

                        <span class="hljs-keyword">if</span> (dgx &gt;= <span class="hljs-number">0</span> &amp;&amp; dgx &lt; gWidth &amp;&amp; dgy &gt;= <span class="hljs-number">0</span> &amp;&amp; dgy &lt; gHeight) {

                            outCell = grid[dgy][dgx];
                            outG[outCell] = inG[inCell];
                        }

                        <span class="hljs-keyword">if</span> (dbx &gt;= <span class="hljs-number">0</span> &amp;&amp; dbx &lt; gWidth &amp;&amp; dby &gt;= <span class="hljs-number">0</span> &amp;&amp; dby &lt; gHeight) {

                            outCell = grid[dby][dbx];
                            outB[outCell] = inB[inCell];
                        }

                        <span class="hljs-keyword">if</span> (dax &gt;= <span class="hljs-number">0</span> &amp;&amp; dax &lt; gWidth &amp;&amp; day &gt;= <span class="hljs-number">0</span> &amp;&amp; day &lt; gHeight) {

                            outCell = grid[day][dax];
                            outA[outCell] = inA[inCell];
                        }
                    }
                }
            }
        }
        <span class="hljs-keyword">let</span> work = <span class="hljs-built_in">this</span>.cache.work.channels;
        <span class="hljs-keyword">if</span> (lineOut) <span class="hljs-built_in">this</span>.processResults(output, work, <span class="hljs-number">1</span> - opacity);
        <span class="hljs-keyword">else</span> <span class="hljs-built_in">this</span>.processResults(work, output, opacity);
    },</pre></div></div>
            
        </li>
        
        
        <li id="section-50">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-50">&#x00a7;</a>
              </div>
              <p><strong>pixelate</strong> - Pixelizes the input image by creating a grid of tiles across it and then averaging the color values of each pixel in a tile and setting its value to the average. Tile width and height, and their offset from the top left corner of the image, are set via the “tileWidth”, “tileHeight”, “offsetX” and “offsetY” arguments.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-string">&#x27;pixelate&#x27;</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">requirements</span>) </span>{

        <span class="hljs-keyword">const</span> doCalculations = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">inChannel, outChannel, tile</span>) </span>{

            <span class="hljs-keyword">let</span> avg = tile.reduce(<span class="hljs-function">(<span class="hljs-params">a, v</span>) =&gt;</span> a + inChannel[v], <span class="hljs-number">0</span>);

            avg = <span class="hljs-built_in">Math</span>.floor(avg / tile.length);

            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>, iz = tile.length; i &lt; iz; i++) {

                outChannel[tile[i]] = avg;
            }
        }

        <span class="hljs-keyword">const</span> setOutValueToInValue = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">inChannel, outChannel, tile</span>) </span>{

            <span class="hljs-keyword">let</span> cell;

            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>, iz = tile.length; i &lt; iz; i++) {

                cell = tile[i];
                outChannel[cell] = inChannel[cell];
            }
        };

        <span class="hljs-keyword">let</span> [input, output] = <span class="hljs-built_in">this</span>.getInputAndOutputChannels(requirements);

        <span class="hljs-keyword">let</span> len = input.r.length;

        <span class="hljs-keyword">let</span> {opacity, tileWidth, tileHeight, offsetX, offsetY, includeRed, includeGreen, includeBlue, includeAlpha, lineOut} = requirements;

        <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> == opacity) opacity = <span class="hljs-number">1</span>;
        <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> == includeRed) includeRed = <span class="hljs-literal">true</span>;
        <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> == includeGreen) includeGreen = <span class="hljs-literal">true</span>;
        <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> == includeBlue) includeBlue = <span class="hljs-literal">true</span>;
        <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> == includeAlpha) includeAlpha = <span class="hljs-literal">false</span>;
        <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> == tileWidth) tileWidth = <span class="hljs-number">1</span>;
        <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> == tileHeight) tileHeight = <span class="hljs-number">1</span>;
        <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> == offsetX) offsetX = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> == offsetY) offsetY = <span class="hljs-number">0</span>;

        <span class="hljs-keyword">const</span> tiles = <span class="hljs-built_in">this</span>.buildImageTileSets(tileWidth, tileHeight, offsetX, offsetY);

        <span class="hljs-keyword">const</span> {<span class="hljs-attr">r</span>:inR, <span class="hljs-attr">g</span>:inG, <span class="hljs-attr">b</span>:inB, <span class="hljs-attr">a</span>:inA} = input;
        <span class="hljs-keyword">const</span> {<span class="hljs-attr">r</span>:outR, <span class="hljs-attr">g</span>:outG, <span class="hljs-attr">b</span>:outB, <span class="hljs-attr">a</span>:outA} = output;

        tiles.forEach(<span class="hljs-function"><span class="hljs-params">t</span> =&gt;</span> {
            <span class="hljs-keyword">if</span> (includeRed) doCalculations(inR, outR, t);
            <span class="hljs-keyword">else</span> setOutValueToInValue(inR, outR, t);

            <span class="hljs-keyword">if</span> (includeGreen) doCalculations(inG, outG, t);
            <span class="hljs-keyword">else</span> setOutValueToInValue(inG, outG, t);

            <span class="hljs-keyword">if</span> (includeBlue) doCalculations(inB, outB, t);
            <span class="hljs-keyword">else</span> setOutValueToInValue(inB, outB, t);

            <span class="hljs-keyword">if</span> (includeAlpha) doCalculations(inA, outA, t);
            <span class="hljs-keyword">else</span> setOutValueToInValue(inA, outA, t);
        })

        <span class="hljs-keyword">let</span> work = <span class="hljs-built_in">this</span>.cache.work.channels;
        <span class="hljs-keyword">if</span> (lineOut) <span class="hljs-built_in">this</span>.processResults(output, work, <span class="hljs-number">1</span> - opacity);
        <span class="hljs-keyword">else</span> <span class="hljs-built_in">this</span>.processResults(work, output, opacity);
    },</pre></div></div>
            
        </li>
        
        
        <li id="section-51">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-51">&#x00a7;</a>
              </div>
              <p><strong>Add an asset image to the filter process chain. The asset - the String name of the asset object - must be pre-loaded before it can be included in the filter. The “width” and “height” arguments are measured in integer Number pixels; the “copy” arguments can be either percentage Strings (relative to the asset’s natural dimensions) or absolute Number values (in pixels). The “lineOut” argument is required - be aware that the filter action does not check for any pre-existing assets cached under this name and, if they exist, will overwrite them with this asset’s data.</strong> - </p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-string">&#x27;process-image&#x27;</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">requirements</span>) </span>{

        <span class="hljs-keyword">const</span> {assetData, lineOut} = requirements;

        <span class="hljs-keyword">if</span> (lineOut &amp;&amp; lineOut.substring &amp;&amp; lineOut.length &amp;&amp; assetData &amp;&amp; assetData.width &amp;&amp; assetData.height &amp;&amp; assetData.data) {

            <span class="hljs-keyword">let</span> d = assetData.data;
            <span class="hljs-keyword">let</span> len = d.length;

            <span class="hljs-keyword">let</span> res = <span class="hljs-built_in">this</span>.createResultObject(len / <span class="hljs-number">4</span>);

            <span class="hljs-keyword">let</span> r = res.r,
                g = res.g,
                b = res.b,
                a = res.a;

            <span class="hljs-keyword">let</span> counter = <span class="hljs-number">0</span>;

            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; len; i += <span class="hljs-number">4</span>) {

                r[counter] = d[i];
                g[counter] = d[i + <span class="hljs-number">1</span>];
                b[counter] = d[i + <span class="hljs-number">2</span>];
                a[counter] = d[i + <span class="hljs-number">3</span>];

                counter++;
            }
            assetData.channels = res;

            <span class="hljs-built_in">this</span>.cache[lineOut] = assetData;
        }
    },</pre></div></div>
            
        </li>
        
        
        <li id="section-52">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-52">&#x00a7;</a>
              </div>
              <p><strong>set-channel-to-level</strong> - Sets the value of each pixel’s included channel to the value supplied in the “level” argument.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-string">&#x27;set-channel-to-level&#x27;</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">requirements</span>) </span>{

        <span class="hljs-keyword">let</span> [input, output] = <span class="hljs-built_in">this</span>.getInputAndOutputChannels(requirements);

        <span class="hljs-keyword">let</span> len = input.r.length;

        <span class="hljs-keyword">let</span> {opacity, includeRed, includeGreen, includeBlue, includeAlpha, level, lineOut} = requirements;

        <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> == opacity) opacity = <span class="hljs-number">1</span>;
        <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> == includeRed) includeRed = <span class="hljs-literal">false</span>;
        <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> == includeGreen) includeGreen = <span class="hljs-literal">false</span>;
        <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> == includeBlue) includeBlue = <span class="hljs-literal">false</span>;
        <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> == includeAlpha) includeAlpha = <span class="hljs-literal">false</span>;
        <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> == level) level = <span class="hljs-number">0</span>;

        <span class="hljs-keyword">const</span> {<span class="hljs-attr">r</span>:inR, <span class="hljs-attr">g</span>:inG, <span class="hljs-attr">b</span>:inB, <span class="hljs-attr">a</span>:inA} = input;
        <span class="hljs-keyword">const</span> {<span class="hljs-attr">r</span>:outR, <span class="hljs-attr">g</span>:outG, <span class="hljs-attr">b</span>:outB, <span class="hljs-attr">a</span>:outA} = output;

        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) {

            outR[i] = (includeRed) ? level : inR[i];
            outG[i] = (includeGreen) ? level : inG[i];
            outB[i] = (includeBlue) ? level : inB[i];
            outA[i] = (includeAlpha) ? level : inA[i];
        }
        <span class="hljs-keyword">let</span> work = <span class="hljs-built_in">this</span>.cache.work.channels;
        <span class="hljs-keyword">if</span> (lineOut) <span class="hljs-built_in">this</span>.processResults(output, work, <span class="hljs-number">1</span> - opacity);
        <span class="hljs-keyword">else</span> <span class="hljs-built_in">this</span>.processResults(work, output, opacity);
    },</pre></div></div>
            
        </li>
        
        
        <li id="section-53">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-53">&#x00a7;</a>
              </div>
              <p><strong>step-channels</strong> - Takes three divisor values - “red”, “green”, “blue”. For each pixel, its color channel values are divided by the corresponding color divisor, floored to the integer value and then multiplied by the divisor. For example a divisor value of ‘50’ applied to a channel value of ‘120’ will give a result of ‘100’. The output is a form of posterization.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-string">&#x27;step-channels&#x27;</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">requirements</span>) </span>{

        <span class="hljs-keyword">let</span> [input, output] = <span class="hljs-built_in">this</span>.getInputAndOutputChannels(requirements);

        <span class="hljs-keyword">let</span> len = input.r.length,
            floor = <span class="hljs-built_in">Math</span>.floor;

        <span class="hljs-keyword">let</span> {opacity, red, green, blue, lineOut} = requirements;

        <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> == opacity) opacity = <span class="hljs-number">1</span>;
        <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> == red) red = <span class="hljs-number">1</span>;
        <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> == green) green = <span class="hljs-number">1</span>;
        <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> == blue) blue = <span class="hljs-number">1</span>;

        <span class="hljs-keyword">if</span> (red == <span class="hljs-literal">null</span>) red = <span class="hljs-number">1</span>;
        <span class="hljs-keyword">if</span> (green == <span class="hljs-literal">null</span>) green = <span class="hljs-number">1</span>;
        <span class="hljs-keyword">if</span> (blue == <span class="hljs-literal">null</span>) blue = <span class="hljs-number">1</span>;

        <span class="hljs-keyword">const</span> {<span class="hljs-attr">r</span>:inR, <span class="hljs-attr">g</span>:inG, <span class="hljs-attr">b</span>:inB, <span class="hljs-attr">a</span>:inA} = input;
        <span class="hljs-keyword">const</span> {<span class="hljs-attr">r</span>:outR, <span class="hljs-attr">g</span>:outG, <span class="hljs-attr">b</span>:outB, <span class="hljs-attr">a</span>:outA} = output;

        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) {
            outR[i] = floor(inR[i] / red) * red;
            outG[i] = floor(inG[i] / green) * green;
            outB[i] = floor(inB[i] / blue) * blue;
            outA[i] = inA[i];
        }

        <span class="hljs-keyword">let</span> work = <span class="hljs-built_in">this</span>.cache.work.channels;
        <span class="hljs-keyword">if</span> (lineOut) <span class="hljs-built_in">this</span>.processResults(output, work, <span class="hljs-number">1</span> - opacity);
        <span class="hljs-keyword">else</span> <span class="hljs-built_in">this</span>.processResults(work, output, opacity);
    },</pre></div></div>
            
        </li>
        
        
        <li id="section-54">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-54">&#x00a7;</a>
              </div>
              <p><strong>threshold</strong> - Grayscales the input then, for each pixel, checks the color channel values against a “level” argument: pixels with channel values above the level value are assigned to the ‘high’ color; otherwise they are updated to the ‘low’ color. The “high” and “low” arguments are [red, green, blue] integer Number Arrays. The convenience function will accept the pseudo-attributes “highRed”, “lowRed” etc in place of the “high” and “low” Arrays.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-string">&#x27;threshold&#x27;</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">requirements</span>) </span>{

        <span class="hljs-keyword">let</span> [input, output] = <span class="hljs-built_in">this</span>.getInputAndOutputChannels(requirements);

        <span class="hljs-keyword">let</span> len = input.r.length;

        <span class="hljs-keyword">let</span> {opacity, low, high, level, lineOut} = requirements;

        <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> == opacity) opacity = <span class="hljs-number">1</span>;
        <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> == low) low = [<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>];
        <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> == high) high = [<span class="hljs-number">255</span>,<span class="hljs-number">255</span>,<span class="hljs-number">255</span>];
        <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> == level) level = <span class="hljs-number">128</span>;

        <span class="hljs-keyword">const</span> {<span class="hljs-attr">r</span>:inR, <span class="hljs-attr">g</span>:inG, <span class="hljs-attr">b</span>:inB, <span class="hljs-attr">a</span>:inA} = input;
        <span class="hljs-keyword">const</span> {<span class="hljs-attr">r</span>:outR, <span class="hljs-attr">g</span>:outG, <span class="hljs-attr">b</span>:outB, <span class="hljs-attr">a</span>:outA} = output;

        <span class="hljs-keyword">let</span> [lowR, lowG, lowB] = low;
        <span class="hljs-keyword">let</span> [highR, highG, highB] = high;

        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) {

            <span class="hljs-keyword">let</span> gray = <span class="hljs-built_in">Math</span>.floor((<span class="hljs-number">0.2126</span> * inR[i]) + (<span class="hljs-number">0.7152</span> * inG[i]) + (<span class="hljs-number">0.0722</span> * inB[i]));

            <span class="hljs-keyword">if</span> (gray &lt; level) {

                outR[i] = lowR;
                outG[i] = lowG;
                outB[i] = lowB;
            }
            <span class="hljs-keyword">else</span> {

                outR[i] = highR;
                outG[i] = highG;
                outB[i] = highB;
            }
            outA[i] = inA[i];
        }

        <span class="hljs-keyword">let</span> work = <span class="hljs-built_in">this</span>.cache.work.channels;
        <span class="hljs-keyword">if</span> (lineOut) <span class="hljs-built_in">this</span>.processResults(output, work, <span class="hljs-number">1</span> - opacity);
        <span class="hljs-keyword">else</span> <span class="hljs-built_in">this</span>.processResults(work, output, opacity);
    },</pre></div></div>
            
        </li>
        
        
        <li id="section-55">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-55">&#x00a7;</a>
              </div>
              <p><strong>tint-channels</strong> - Has similarities to the SVG &lt;feColorMatrix&gt; filter element, but excludes the alpha channel from calculations. Rather than set a matrix, we set nine arguments to determine how the value of each color channel in a pixel will affect both itself and its fellow color channels. The ‘sepia’ convenience filter presets these values to create a sepia effect.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-string">&#x27;tint-channels&#x27;</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">requirements</span>) </span>{

        <span class="hljs-keyword">let</span> [input, output] = <span class="hljs-built_in">this</span>.getInputAndOutputChannels(requirements);

        <span class="hljs-keyword">let</span> len = input.r.length;

        <span class="hljs-keyword">let</span> {opacity, redInRed, redInGreen, redInBlue, greenInRed, greenInGreen, greenInBlue, blueInRed, blueInGreen, blueInBlue, lineOut} = requirements;

        <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> == opacity) opacity = <span class="hljs-number">1</span>;
        <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> == redInRed) redInRed = <span class="hljs-number">1</span>;
        <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> == redInGreen) redInGreen = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> == redInBlue) redInBlue = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> == greenInRed) greenInRed = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> == greenInGreen) greenInGreen = <span class="hljs-number">1</span>;
        <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> == greenInBlue) greenInBlue = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> == blueInRed) blueInRed = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> == blueInGreen) blueInGreen = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> == blueInBlue) blueInBlue = <span class="hljs-number">1</span>;

        <span class="hljs-keyword">const</span> {<span class="hljs-attr">r</span>:inR, <span class="hljs-attr">g</span>:inG, <span class="hljs-attr">b</span>:inB, <span class="hljs-attr">a</span>:inA} = input;
        <span class="hljs-keyword">const</span> {<span class="hljs-attr">r</span>:outR, <span class="hljs-attr">g</span>:outG, <span class="hljs-attr">b</span>:outB, <span class="hljs-attr">a</span>:outA} = output;

        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) {

            <span class="hljs-keyword">let</span> r = inR[i],
                g = inG[i],
                b = inB[i];

            outR[i] = <span class="hljs-built_in">Math</span>.floor((r * redInRed) + (g * greenInRed) + (b * blueInRed));
            outG[i] = <span class="hljs-built_in">Math</span>.floor((r * redInGreen) + (g * greenInGreen) + (b * blueInGreen));
            outB[i] = <span class="hljs-built_in">Math</span>.floor((r * redInBlue) + (g * greenInBlue) + (b * blueInBlue));
            outA[i] = inA[i];
        }

        <span class="hljs-keyword">let</span> work = <span class="hljs-built_in">this</span>.cache.work.channels;
        <span class="hljs-keyword">if</span> (lineOut) <span class="hljs-built_in">this</span>.processResults(output, work, <span class="hljs-number">1</span> - opacity);
        <span class="hljs-keyword">else</span> <span class="hljs-built_in">this</span>.processResults(work, output, opacity);
    },</pre></div></div>
            
        </li>
        
        
        <li id="section-56">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-56">&#x00a7;</a>
              </div>
              <p><strong>user-defined-legacy</strong> - Previous to version 8.4, filters could be defined with an argument which passed a function string to the filter worker, which the worker would then run against the source input image as-and-when required. This functionality has been removed from the new filter system. All such filters will now return the input image unchanged.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
    <span class="hljs-string">&#x27;user-defined-legacy&#x27;</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">requirements</span>) </span>{

        <span class="hljs-keyword">let</span> [input, output] = <span class="hljs-built_in">this</span>.getInputAndOutputChannels(requirements);

        <span class="hljs-keyword">let</span> {opacity, lineOut} = requirements;

        <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> == opacity) opacity = <span class="hljs-number">1</span>;

        <span class="hljs-built_in">this</span>.copyOver(input, output);

        <span class="hljs-keyword">let</span> work = <span class="hljs-built_in">this</span>.cache.work.channels;
        <span class="hljs-keyword">if</span> (lineOut) <span class="hljs-built_in">this</span>.processResults(output, work, <span class="hljs-number">1</span> - opacity);
        <span class="hljs-keyword">else</span> <span class="hljs-built_in">this</span>.processResults(work, output, opacity);
    },
};</pre></div></div>
            
        </li>
        
        
        <li id="section-57">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-57">&#x00a7;</a>
              </div>
              <h4 id="factory">Factory</h4>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-keyword">const</span> makeFilterEngine = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">items = {}</span>) </span>{

    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> FilterEngine(items);
};

<span class="hljs-title">constructors</span>.<span class="hljs-title">FilterEngine</span> = <span class="hljs-title">FilterEngine</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-58">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-58">&#x00a7;</a>
              </div>
              <h4 id="exports">Exports</h4>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-keyword">export</span> {
    makeFilterEngine,
};</pre></div></div>
            
        </li>
        
    </ul>
  </div>
</body>
</html>

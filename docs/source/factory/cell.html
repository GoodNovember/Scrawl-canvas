<!DOCTYPE html>

<html>
<head>
  <title>Cell factory</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, target-densitydpi=160dpi, initial-scale=1.0; maximum-scale=1.0; user-scalable=0;">
  <link rel="stylesheet" media="all" href="../../docco.css" />
</head>
<body>
  <div id="container">
    <div id="background"></div>
    
      <ul id="jump_to">
        <li>
          <a class="large" href="javascript:void(0);">Jump To &hellip;</a>
          <a class="small" href="javascript:void(0);">+</a>
          <div id="jump_wrapper">
          <div id="jump_page_wrapper">
            <div id="jump_page">
              
                
                <a class="source" href="../core/animationloop.html">
                  ./source/core/animationloop.js
                </a>
              
                
                <a class="source" href="../core/document.html">
                  ./source/core/document.js
                </a>
              
                
                <a class="source" href="../core/events.html">
                  ./source/core/events.js
                </a>
              
                
                <a class="source" href="../core/init.html">
                  ./source/core/init.js
                </a>
              
                
                <a class="source" href="../core/library.html">
                  ./source/core/library.js
                </a>
              
                
                <a class="source" href="../core/snippets.html">
                  ./source/core/snippets.js
                </a>
              
                
                <a class="source" href="../core/userInteraction.html">
                  ./source/core/userInteraction.js
                </a>
              
                
                <a class="source" href="../core/utilities.html">
                  ./source/core/utilities.js
                </a>
              
                
                <a class="source" href="action.html">
                  ./source/factory/action.js
                </a>
              
                
                <a class="source" href="anchor.html">
                  ./source/factory/anchor.js
                </a>
              
                
                <a class="source" href="animation.html">
                  ./source/factory/animation.js
                </a>
              
                
                <a class="source" href="bezier.html">
                  ./source/factory/bezier.js
                </a>
              
                
                <a class="source" href="block.html">
                  ./source/factory/block.js
                </a>
              
                
                <a class="source" href="canvas.html">
                  ./source/factory/canvas.js
                </a>
              
                
                <a class="source" href="cell.html">
                  ./source/factory/cell.js
                </a>
              
                
                <a class="source" href="cog.html">
                  ./source/factory/cog.js
                </a>
              
                
                <a class="source" href="color.html">
                  ./source/factory/color.js
                </a>
              
                
                <a class="source" href="conicGradient.html">
                  ./source/factory/conicGradient.js
                </a>
              
                
                <a class="source" href="coordinate.html">
                  ./source/factory/coordinate.js
                </a>
              
                
                <a class="source" href="element.html">
                  ./source/factory/element.js
                </a>
              
                
                <a class="source" href="emitter.html">
                  ./source/factory/emitter.js
                </a>
              
                
                <a class="source" href="filter.html">
                  ./source/factory/filter.js
                </a>
              
                
                <a class="source" href="filterEngine.html">
                  ./source/factory/filterEngine.js
                </a>
              
                
                <a class="source" href="fontAttributes.html">
                  ./source/factory/fontAttributes.js
                </a>
              
                
                <a class="source" href="gradient.html">
                  ./source/factory/gradient.js
                </a>
              
                
                <a class="source" href="grid.html">
                  ./source/factory/grid.js
                </a>
              
                
                <a class="source" href="group.html">
                  ./source/factory/group.js
                </a>
              
                
                <a class="source" href="imageAsset.html">
                  ./source/factory/imageAsset.js
                </a>
              
                
                <a class="source" href="line.html">
                  ./source/factory/line.js
                </a>
              
                
                <a class="source" href="lineSpiral.html">
                  ./source/factory/lineSpiral.js
                </a>
              
                
                <a class="source" href="loom.html">
                  ./source/factory/loom.js
                </a>
              
                
                <a class="source" href="mesh.html">
                  ./source/factory/mesh.js
                </a>
              
                
                <a class="source" href="net.html">
                  ./source/factory/net.js
                </a>
              
                
                <a class="source" href="noise.html">
                  ./source/factory/noise.js
                </a>
              
                
                <a class="source" href="oval.html">
                  ./source/factory/oval.js
                </a>
              
                
                <a class="source" href="palette.html">
                  ./source/factory/palette.js
                </a>
              
                
                <a class="source" href="particle.html">
                  ./source/factory/particle.js
                </a>
              
                
                <a class="source" href="particleForce.html">
                  ./source/factory/particleForce.js
                </a>
              
                
                <a class="source" href="particleHistory.html">
                  ./source/factory/particleHistory.js
                </a>
              
                
                <a class="source" href="particleSpring.html">
                  ./source/factory/particleSpring.js
                </a>
              
                
                <a class="source" href="particleWorld.html">
                  ./source/factory/particleWorld.js
                </a>
              
                
                <a class="source" href="pattern.html">
                  ./source/factory/pattern.js
                </a>
              
                
                <a class="source" href="phrase.html">
                  ./source/factory/phrase.js
                </a>
              
                
                <a class="source" href="picture.html">
                  ./source/factory/picture.js
                </a>
              
                
                <a class="source" href="polygon.html">
                  ./source/factory/polygon.js
                </a>
              
                
                <a class="source" href="polyline.html">
                  ./source/factory/polyline.js
                </a>
              
                
                <a class="source" href="quadratic.html">
                  ./source/factory/quadratic.js
                </a>
              
                
                <a class="source" href="quaternion.html">
                  ./source/factory/quaternion.js
                </a>
              
                
                <a class="source" href="radialGradient.html">
                  ./source/factory/radialGradient.js
                </a>
              
                
                <a class="source" href="rectangle.html">
                  ./source/factory/rectangle.js
                </a>
              
                
                <a class="source" href="renderAnimation.html">
                  ./source/factory/renderAnimation.js
                </a>
              
                
                <a class="source" href="shape.html">
                  ./source/factory/shape.js
                </a>
              
                
                <a class="source" href="spiral.html">
                  ./source/factory/spiral.js
                </a>
              
                
                <a class="source" href="spriteAsset.html">
                  ./source/factory/spriteAsset.js
                </a>
              
                
                <a class="source" href="stack.html">
                  ./source/factory/stack.js
                </a>
              
                
                <a class="source" href="star.html">
                  ./source/factory/star.js
                </a>
              
                
                <a class="source" href="state.html">
                  ./source/factory/state.js
                </a>
              
                
                <a class="source" href="tetragon.html">
                  ./source/factory/tetragon.js
                </a>
              
                
                <a class="source" href="ticker.html">
                  ./source/factory/ticker.js
                </a>
              
                
                <a class="source" href="tracer.html">
                  ./source/factory/tracer.js
                </a>
              
                
                <a class="source" href="tween.html">
                  ./source/factory/tween.js
                </a>
              
                
                <a class="source" href="unstackedElement.html">
                  ./source/factory/unstackedElement.js
                </a>
              
                
                <a class="source" href="vector.html">
                  ./source/factory/vector.js
                </a>
              
                
                <a class="source" href="videoAsset.html">
                  ./source/factory/videoAsset.js
                </a>
              
                
                <a class="source" href="wheel.html">
                  ./source/factory/wheel.js
                </a>
              
                
                <a class="source" href="../mixin/anchor.html">
                  ./source/mixin/anchor.js
                </a>
              
                
                <a class="source" href="../mixin/asset.html">
                  ./source/mixin/asset.js
                </a>
              
                
                <a class="source" href="../mixin/assetConsumer.html">
                  ./source/mixin/assetConsumer.js
                </a>
              
                
                <a class="source" href="../mixin/base.html">
                  ./source/mixin/base.js
                </a>
              
                
                <a class="source" href="../mixin/cascade.html">
                  ./source/mixin/cascade.js
                </a>
              
                
                <a class="source" href="../mixin/delta.html">
                  ./source/mixin/delta.js
                </a>
              
                
                <a class="source" href="../mixin/displayShape.html">
                  ./source/mixin/displayShape.js
                </a>
              
                
                <a class="source" href="../mixin/dom.html">
                  ./source/mixin/dom.js
                </a>
              
                
                <a class="source" href="../mixin/entity.html">
                  ./source/mixin/entity.js
                </a>
              
                
                <a class="source" href="../mixin/filter.html">
                  ./source/mixin/filter.js
                </a>
              
                
                <a class="source" href="../mixin/mimic.html">
                  ./source/mixin/mimic.js
                </a>
              
                
                <a class="source" href="../mixin/path.html">
                  ./source/mixin/path.js
                </a>
              
                
                <a class="source" href="../mixin/pattern.html">
                  ./source/mixin/pattern.js
                </a>
              
                
                <a class="source" href="../mixin/pivot.html">
                  ./source/mixin/pivot.js
                </a>
              
                
                <a class="source" href="../mixin/position.html">
                  ./source/mixin/position.js
                </a>
              
                
                <a class="source" href="../mixin/shapeBasic.html">
                  ./source/mixin/shapeBasic.js
                </a>
              
                
                <a class="source" href="../mixin/shapeCurve.html">
                  ./source/mixin/shapeCurve.js
                </a>
              
                
                <a class="source" href="../mixin/shapePathCalculation.html">
                  ./source/mixin/shapePathCalculation.js
                </a>
              
                
                <a class="source" href="../mixin/styles.html">
                  ./source/mixin/styles.js
                </a>
              
                
                <a class="source" href="../mixin/tween.html">
                  ./source/mixin/tween.js
                </a>
              
            </div>
          </div>
        </li>
      </ul>
    
    <ul class="sections">
        
        
        
        <li id="section-1">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-1">&#x00a7;</a>
              </div>
              <h1 id="cell-factory">Cell factory</h1>
<p>Scrawl-canvas uses ‘hidden’ canvases - &lt;canvas&gt; elements that are not part of the DOM - for much of its functionality:</p>
<ul>
<li>When we wrap a DOM-based &lt;canvas&gt; element in a Scrawl-canvas <a href="./canvas.html">Canvas</a> wrapper, we create a second ‘hidden’ &lt;canvas&gt; element and assign it as that Canvas wrapper’s <strong>base cell</strong>. </li>
<li>This Cell is used for building the display during the Display cycle (<code>clear</code> and <code>compile</code> steps). </li>
<li>It gets copied over to the Dom-based &lt;canvas&gt; element at the end of the cycle (the <code>show</code> step).</li>
<li>When copied over, the base cell will determine how much of its display to copy into the controller Canvas, to meet the needs of that Canvas wrapper’s <code>fit</code> attribute.</li>
</ul>
<p>A Scrawl-canvas Canvas wrapper can have more than one Cell wrapper associated with it. These additional Cells can be used as:</p>
<ul>
<li><strong>layers</strong> to be applied to the base cell, allowing us to break a canvas display into more manageable portions</li>
<li>the source for image-based objects such as <strong>Picture entitys</strong> and <strong>Pattern styles</strong>.</li>
<li><strong>artefacts</strong> - a Cell wrapper can act just like any artefact: it can be positioned, dimensioned, scaled and rotated ; it can act as a <code>pivot</code> or <code>mimic</code> source for other artefacts, or use them for its position and dimensions data. (Be aware, though, that Cell wrappers are NOT stored in the scrawl library’s <code>artefact</code> section).</li>
</ul>
<p>Cell wrappers include a number of Boolean flags and other attributes to control how they are stamped onto other Cells. </p>
<ul>
<li>We can set flags to determine whether to include the Cell in each step of the Display cycle (<code>cleared</code>, <code>compiled</code>, <code>shown</code>) - this allows us to set up, for example, ‘static’ Cells that only need to be compiled once and can then be used as backgrounds for other Cells and entitys to be animated over.</li>
<li>We can vary the order in which Cell wrappers get processed during the Display cycle (<code>compileOrder</code>, <code>showOrder</code>). </li>
<li>Each Cell can have its own <code>backgroundColor</code>.</li>
<li>Each Cell can be made translucent (<code>alpha</code>).</li>
<li>Each Cell can be stamped onto other Cell canvases using a different composition method (<code>composite</code>).</li>
<li>Each Cell can be given its own dimensions, different to those of its Canvas wrapper, with updates cascading down to entitys that use the Cell to determine their own (relative) dimensions and start coordinates. </li>
<li>We can <code>scale</code>, <code>roll</code> and <code>flip</code> a Cell.</li>
<li>We can control which parts of the Cell display will be copied over to its destination (<code>copy attributes</code>).</li>
<li>We can add one or more <code>filters</code> to the Cell’s outputted display.</li>
</ul>
<p>Every Cell wrapper will include a <a href="./group.html">Group object</a> which shares the same name as the Cell. To include an entity object in a Cell wrapper’s canvas display we add it to this group. </p>
<ul>
<li>Additional Group objects can be added to the Cell wrapper as-and-when required. </li>
<li>Groups are processed in the order specified in their <code>order</code> attributes.</li>
<li>Groups whose <code>visibility</code> flag is set to false will be skipped during the Display cycle cascade.</li>
</ul>
<p>Scrawl-canvas uses the <code>makeCell</code> factory function internally; it is not exported to the scrawl object. Instead, <em><strong>new Cell wrappers can be created from a Canvas wrapper</strong></em> using its <code>addCell</code> function.</p>
<p>Scrawl-canvas (partially) disables Cell wrapper <code>packet</code> functionality. <em><strong>Cell wrappers cannot be cloned.</strong></em> They can be killed, either using their <code>kill</code> function or by invoking their Canvas wrapper controller’s <code>killCell</code> function.</p>

            </div>
            
        </li>
        
        
        <li id="section-2">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-2">&#x00a7;</a>
              </div>
              <h4 id="demos">Demos:</h4>
<ul>
<li>All canvas and component demos, and a few of the stack demos, include Cell wrapper functionality - most of which happens behind the scenes and does not need to be directly coded. </li>
<li><a href="../../demo/canvas-009.html">Canvas-009</a> - Pattern styles; Entity web link anchors; Dynamic accessibility</li>
<li><a href="../../demo/canvas-031.html">Canvas-031</a> - Cell generation and processing order - kaleidoscope clock</li>
<li><a href="../../demo/canvas-036.html">Canvas-036</a> - Cell artefact-like positional functionality</li>
<li><a href="../../demo/canvas-039.html">Canvas-039</a> - Detecting mouse/pointer cursor movements across a non-base Cell</li>
<li><a href="../../demo/dom-011.html">DOM-011</a> - Canvas controller <code>fit</code> attribute; Cell positioning (mouse)</li>
</ul>

            </div>
            
        </li>
        
        
        <li id="section-3">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-3">&#x00a7;</a>
              </div>
              <h4 id="imports">Imports</h4>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-keyword">import</span> { artefact, asset, tween, radian, <span class="hljs-title">constructors</span>, <span class="hljs-title">styles</span>, <span class="hljs-title">stylesnames</span>, <span class="hljs-title">cell</span>, <span class="hljs-title">cellnames</span>, <span class="hljs-title">group</span>, <span class="hljs-title">canvas</span> } <span class="hljs-title">from</span> &#x27;../<span class="hljs-title">core</span>/<span class="hljs-title">library</span>.<span class="hljs-title">js</span>&#x27;;

<span class="hljs-keyword">import</span> { generateUniqueString, isa_canvas, mergeOver, λ<span class="hljs-built_in">this</span>, λ<span class="hljs-literal">null</span>, Ωempty } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../core/utilities.js&#x27;</span>;

<span class="hljs-keyword">import</span> { scrawlCanvasHold } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../core/document.js&#x27;</span>;

<span class="hljs-keyword">import</span> { makeGroup } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./group.js&#x27;</span>;
<span class="hljs-keyword">import</span> { makeState } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./state.js&#x27;</span>;
<span class="hljs-keyword">import</span> { makeCoordinate, requestCoordinate, releaseCoordinate } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./coordinate.js&#x27;</span>;
<span class="hljs-keyword">import</span> { filterEngine } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./filterEngine.js&#x27;</span>;
<span class="hljs-keyword">import</span> { importDomImage } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./imageAsset.js&#x27;</span>;

<span class="hljs-keyword">import</span> baseMix <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../mixin/base.js&#x27;</span>;
<span class="hljs-keyword">import</span> positionMix <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../mixin/position.js&#x27;</span>;
<span class="hljs-keyword">import</span> deltaMix <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../mixin/delta.js&#x27;</span>;
<span class="hljs-keyword">import</span> pivotMix <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../mixin/pivot.js&#x27;</span>;
<span class="hljs-keyword">import</span> mimicMix <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../mixin/mimic.js&#x27;</span>;
<span class="hljs-keyword">import</span> pathMix <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../mixin/path.js&#x27;</span>;
<span class="hljs-keyword">import</span> anchorMix <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../mixin/anchor.js&#x27;</span>;
<span class="hljs-keyword">import</span> cascadeMix <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../mixin/cascade.js&#x27;</span>;
<span class="hljs-keyword">import</span> assetMix <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../mixin/asset.js&#x27;</span>;
<span class="hljs-keyword">import</span> patternMix <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../mixin/pattern.js&#x27;</span>;
<span class="hljs-keyword">import</span> filterMix <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../mixin/filter.js&#x27;</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-4">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-4">&#x00a7;</a>
              </div>
              <h4 id="cell-constructor">Cell constructor</h4>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-keyword">const</span> Cell = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">items = Ωempty</span>) </span>{

    <span class="hljs-built_in">this</span>.makeName(items.name);

    <span class="hljs-keyword">if</span> (!items.isPool) <span class="hljs-built_in">this</span>.register();

    <span class="hljs-built_in">this</span>.initializePositions();
    <span class="hljs-built_in">this</span>.initializeCascade();

    <span class="hljs-keyword">if</span> (!isa_canvas(items.element)) {

        <span class="hljs-keyword">let</span> mycanvas = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&#x27;canvas&#x27;</span>);
        mycanvas.id = <span class="hljs-built_in">this</span>.name;

        mycanvas.width = <span class="hljs-number">300</span>;
        mycanvas.height = <span class="hljs-number">150</span>;
        items.element = mycanvas;
    }

    <span class="hljs-built_in">this</span>.installElement(items.element);

    <span class="hljs-keyword">if</span> (items.isPool) <span class="hljs-built_in">this</span>.set(<span class="hljs-built_in">this</span>.poolDefs) 
    <span class="hljs-keyword">else</span> <span class="hljs-built_in">this</span>.set(<span class="hljs-built_in">this</span>.defs);

    <span class="hljs-built_in">this</span>.set(items);

    <span class="hljs-built_in">this</span>.state.setStateFromEngine(<span class="hljs-built_in">this</span>.engine);

    <span class="hljs-keyword">if</span> (!items.isPool) {

        makeGroup({
            <span class="hljs-attr">name</span>: <span class="hljs-built_in">this</span>.name,
            <span class="hljs-attr">host</span>: <span class="hljs-built_in">this</span>.name
        });
    }

    <span class="hljs-built_in">this</span>.subscribers = [];
    <span class="hljs-built_in">this</span>.sourceNaturalDimensions = makeCoordinate();

    <span class="hljs-built_in">this</span>.sourceLoaded = <span class="hljs-literal">true</span>;

    <span class="hljs-built_in">this</span>.here = {};

    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;
};</pre></div></div>
            
        </li>
        
        
        <li id="section-5">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-5">&#x00a7;</a>
              </div>
              <h4 id="cell-prototype">Cell prototype</h4>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-keyword">let</span> P = Cell.prototype = <span class="hljs-built_in">Object</span>.create(<span class="hljs-built_in">Object</span>.prototype);
P.type = <span class="hljs-string">&#x27;Cell&#x27;</span>;
P.lib = <span class="hljs-string">&#x27;cell&#x27;</span>;
P.isArtefact = <span class="hljs-literal">false</span>;
P.isAsset = <span class="hljs-literal">true</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-6">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-6">&#x00a7;</a>
              </div>
              <h4 id="mixins">Mixins</h4>
<ul>
<li><a href="../mixin/base.html">base</a></li>
<li><a href="../mixin/asset.html">asset</a> - goes above position mixin because asset objects use the kill function defined in this mixin, but Cells need to follow the position mixin formula (which includes a call to the factoryKill function)</li>
<li><a href="../mixin/position.html">position</a></li>
<li><a href="../mixin/delta.html">delta</a></li>
<li><a href="../mixin/pivot.html">pivot</a></li>
<li><a href="../mixin/mimic.html">mimic</a></li>
<li><a href="../mixin/path.html">path</a></li>
<li><a href="../mixin/anchor.html">anchor</a></li>
<li><a href="../mixin/cascade.html">cascade</a></li>
<li><a href="../mixin/pattern.html">pattern</a></li>
<li><a href="../mixin/filter.html">filter</a></li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>P = baseMix(P);
P = assetMix(P);
P = positionMix(P);
P = deltaMix(P);
P = pivotMix(P);
P = mimicMix(P);
P = pathMix(P);
P = anchorMix(P);
P = cascadeMix(P);
P = patternMix(P);
P = filterMix(P);</pre></div></div>
            
        </li>
        
        
        <li id="section-7">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-7">&#x00a7;</a>
              </div>
              <h4 id="cell-attributes">Cell attributes</h4>
<ul>
<li>Attributes defined in the <a href="../mixin/base.html">base mixin</a>: <strong>name</strong>.</li>
<li>Attributes defined in the <a href="../mixin/position.html">position mixin</a>: <strong>group, visibility, order, start, <em>startX</em>, <em>startY</em>, handle, <em>handleX</em>, <em>handleY</em>, offset, <em>offsetX</em>, <em>offsetY</em>, dimensions, <em>width</em>, <em>height</em>, pivoted, mimicked, lockTo, <em>lockXTo</em>, <em>lockYTo</em>, scale, roll, noUserInteraction, noPositionDependencies, noCanvasEngineUpdates, noFilters, noPathUpdates, purge, bringToFrontOnDrag</strong>.</li>
<li>Attributes defined in the <a href="../mixin/delta.html">delta mixin</a>: <strong>delta, noDeltaUpdates</strong>.</li>
<li>Attributes defined in the <a href="../mixin/pivot.html">pivot mixin</a>: <strong>pivot, pivotCorner, addPivotHandle, addPivotOffset, addPivotRotation</strong>.</li>
<li>Attributes defined in the <a href="../mixin/mimic.html">mimic mixin</a>: <strong>mimic, useMimicDimensions, useMimicScale, useMimicStart, useMimicHandle, useMimicOffset, useMimicRotation, useMimicFlip, addOwnDimensionsToMimic, addOwnScaleToMimic, addOwnStartToMimic, addOwnHandleToMimic, addOwnOffsetToMimic, addOwnRotationToMimic</strong>.</li>
<li>Attributes defined in the <a href="../mixin/path.html">path mixin</a>: <strong>path, pathPosition, addPathHandle, addPathOffset, addPathRotation, constantPathSpeed</strong>.</li>
<li>Attributes defined in the <a href="../mixin/anchor.html">anchor mixin</a>: <strong>anchor</strong>.</li>
<li>Attributes defined in the <a href="../mixin/filter.html">filter mixin</a>: <strong>filters, isStencil</strong>.</li>
<li>Attributes defined in the <a href="../mixin/cascade.html">cascade mixin</a>: <strong>groups</strong>.</li>
<li>Attributes defined in the <a href="../mixin/pattern.html">pattern mixin</a>: <strong>repeat, patternMatrix, matrixA, matrixB, matrixC, matrixD, matrixE, matrixF</strong>.</li>
<li>Attributes defined in the <a href="../mixin/asset.html">asset mixin</a>: <strong>source, subscribers</strong>.</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-keyword">let</span> defaultAttributes = {</pre></div></div>
            
        </li>
        
        
        <li id="section-8">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-8">&#x00a7;</a>
              </div>
              <p>The following booleans determine whether a Cell canvas will, clear, compile and/or show itself as part of the Display cycle.</p>
<ul>
<li>Note that as part of the Display cycle, Scrawl-canvas will complete all tasks of the <code>clear</code> part of the process before moving on to the <code>compile</code> stage, which again will complete before the <code>show</code> stage triggers.</li>
</ul>

            </div>
            
        </li>
        
        
        <li id="section-9">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-9">&#x00a7;</a>
              </div>
              <p><strong>cleared</strong> - Clearing the cell wipes it clean ready for new drawing activity - for cells that contain static imagery (such as a background) that only needs to be drawn once during an animation it makes no sense to construct its display on each iteration of the Display cycle. Can also be set to false if the compile step builds on, rather than replaces, the cell’s current imagery.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    cleared: <span class="hljs-literal">true</span>,</pre></div></div>
            
        </li>
        
        
        <li id="section-10">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-10">&#x00a7;</a>
              </div>
              <p><strong>compiled</strong> - Compiling the cell triggers the ‘stamp cascade’, where (visible) entitys in (visible) groups assigned to the cell are instructed to stamp themselves onto the cell. Again, set this to false if the cell’s imagery does not need to be redrawn on each iteration of the Display cycle.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    compiled: <span class="hljs-literal">true</span>,</pre></div></div>
            
        </li>
        
        
        <li id="section-11">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-11">&#x00a7;</a>
              </div>
              <p><strong>shown</strong> - Showing the cell instructs it to stamp itself onto the ‘base’ cell or, for base cells, to stamp itself onto the display &lt;canvas&gt; element in line with that canvas’s wrapper’s ‘fit’ attribute. This can be switched off if the cell is (for instance) being used as an asset source for a Picture entity or Pattern style.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    shown: <span class="hljs-literal">true</span>,</pre></div></div>
            
        </li>
        
        
        <li id="section-12">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-12">&#x00a7;</a>
              </div>
              <p>Cells will compile and show in the order given (ascending) of their <strong>compileOrder</strong> and <strong>showOrder</strong> values. Cells sharing a compileOrder or showOrder value will be compiled and shown determined by the order in which they were declared in the script where they were created.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    compileOrder: <span class="hljs-number">0</span>,
    <span class="hljs-attr">showOrder</span>: <span class="hljs-number">0</span>,</pre></div></div>
            
        </li>
        
        
        <li id="section-13">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-13">&#x00a7;</a>
              </div>
              <p>By default, cells have a background color of <code>rgba(0,0,0,0)</code> - transparent black, which gets applied as the end step in the clear part of the display cycle. Setting the <strong>backgroundColor</strong> attribute ensures the Cell will use that color instead. Any CSS color String is a valid argument (but not gradients or patterns, which get applied at a later stage in the Display cycle).</p>
<ul>
<li>Base cells can have this attribute set via their controller Canvas.</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>    backgroundColor: <span class="hljs-string">&#x27;&#x27;</span>,</pre></div></div>
            
        </li>
        
        
        <li id="section-14">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-14">&#x00a7;</a>
              </div>
              <p><strong>clearAlpha</strong> - a Number with a value between 0 and 1. When not zero, the cell will not clear itself; rather it will copy its current contents, clear itself, set its globalAlpha to this value, copy back its contents (now faded) and then restore its globalAlpha value</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    clearAlpha: <span class="hljs-number">0</span>,</pre></div></div>
            
        </li>
        
        
        <li id="section-15">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-15">&#x00a7;</a>
              </div>
              <p>Non-base Cells will stamp themselves onto the ‘base’ Cell as part of the Display cycle’s show stage. We can mediate this action by setting the Cell’s <strong>alpha</strong> and <strong>composite</strong> attributes to valid Rendering2DContext <code>globalAlpha</code> and <code>globalCompositeOperation</code> values.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    alpha: <span class="hljs-number">1</span>,
    <span class="hljs-attr">composite</span>: <span class="hljs-string">&#x27;source-over&#x27;</span>,</pre></div></div>
            
        </li>
        
        
        <li id="section-16">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-16">&#x00a7;</a>
              </div>
              <p>We can also scale the Cell’s size in the displayed Canvas by setting the <strong>scale</strong> attribute to an appropriate value.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    scale: <span class="hljs-number">1</span>,</pre></div></div>
            
        </li>
        
        
        <li id="section-17">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-17">&#x00a7;</a>
              </div>
              <p><strong>flipReverse</strong>, <strong>flipUpend</strong> - Boolean flags which determine the orientation of the cell when it stamps itself on the display. </p>
<ul>
<li>a <code>reversed</code> cell is effectively flipped 180&deg; around a vertical line passing through that cell’s rotation-reflection (start) point - a face looking to the right will now look to the left</li>
<li>an <code>upended</code> cell is effectively flipped 180&deg; around a horizontal line passing through that cell’s rotation-reflection (start) point - a normal face will now appear upside-down</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>    flipReverse: <span class="hljs-literal">false</span>,
    <span class="hljs-attr">flipUpend</span>: <span class="hljs-literal">false</span>,</pre></div></div>
            
        </li>
        
        
        <li id="section-18">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-18">&#x00a7;</a>
              </div>
              <p><strong>filter</strong> - the Canvas 2D engine supports the <a href="https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/filter">filter attribute</a> on an experimental basis, thus it is not guaranteed to work in all browsers and devices. The filter attribute takes a String value (default: ‘none’) defining one or more filter functions to be applied to the Cell as it is stamped on its host canvas.</p>
<ul>
<li>Be aware that Cells can also take a <code>filters</code> Array - this represents an array of Scrawl-canvas filters to be applied to the Cell. The two filter systems are completely separate - combine their effects at your own risk!</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>    filter: <span class="hljs-string">&#x27;none&#x27;</span>,</pre></div></div>
            
        </li>
        
        
        <li id="section-19">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-19">&#x00a7;</a>
              </div>
              <p>Scrawl-canvas sets the following attributes automatically; do not change their values!</p>

            </div>
            
        </li>
        
        
        <li id="section-20">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-20">&#x00a7;</a>
              </div>
              <p><strong>isBase</strong> - Every displayed &lt;canvas&gt; element - wrapped in a Scrawl-canvas Canvas object (factory/canvas.js) - must possess at least one Cell object, known as its ‘base’ Cell. </p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    isBase: <span class="hljs-literal">false</span>,</pre></div></div>
            
        </li>
        
        
        <li id="section-21">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-21">&#x00a7;</a>
              </div>
              <p><strong>controller</strong> - A reference link to the displayed &lt;canvas&gt; element’s Scrawl-canvas wrapper (factory/canvas.js) - only ‘base’ cells require this handle.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    controller: <span class="hljs-literal">null</span>,
};
P.defs = mergeOver(P.defs, defaultAttributes);</pre></div></div>
            
        </li>
        
        
        <li id="section-22">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-22">&#x00a7;</a>
              </div>
              <p>Cells don’t have a need for these default attributes, which will have been added in by mixin/asset.js</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-keyword">delete</span> P.defs.source;
<span class="hljs-keyword">delete</span> P.defs.sourceLoaded;</pre></div></div>
            
        </li>
        
        
        <li id="section-23">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-23">&#x00a7;</a>
              </div>
              <h4 id="packetclone-management">Packet/Clone management</h4>
<p>This functionality is disabled for Cell objects</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>P.stringifyFunction = λ<span class="hljs-literal">null</span>;
P.processPacketOut = λ<span class="hljs-literal">null</span>;
P.finalizePacketOut = λ<span class="hljs-literal">null</span>;
P.saveAsPacket = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{

    <span class="hljs-keyword">return</span> <span class="hljs-string">`[<span class="hljs-subst">${<span class="hljs-built_in">this</span>.name}</span>, <span class="hljs-subst">${<span class="hljs-built_in">this</span>.type}</span>, <span class="hljs-subst">${<span class="hljs-built_in">this</span>.lib}</span>, {}]`</span>
};
P.clone = λ<span class="hljs-built_in">this</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-24">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-24">&#x00a7;</a>
              </div>
              <h4 id="kill-functionality">Kill functionality</h4>

            </div>
            
            <div class="content"><div class='highlight'><pre>P.factoryKill = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{

    <span class="hljs-keyword">let</span> myname = <span class="hljs-built_in">this</span>.name</pre></div></div>
            
        </li>
        
        
        <li id="section-25">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-25">&#x00a7;</a>
              </div>
              <p>Remove artefact from all canvases</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-built_in">Object</span>.entries(canvas).forEach(<span class="hljs-function">(<span class="hljs-params">[name, cvs]</span>) =&gt;</span> {

        <span class="hljs-keyword">if</span> (cvs.cells.indexOf(myname) &gt;= <span class="hljs-number">0</span>) cvs.removeCell(myname);

        <span class="hljs-keyword">if</span> (cvs.base &amp;&amp; cvs.base.name === myname) {

            cvs.set({
                <span class="hljs-attr">visibility</span>: <span class="hljs-literal">false</span>,
            });
        }
    });</pre></div></div>
            
        </li>
        
        
        <li id="section-26">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-26">&#x00a7;</a>
              </div>
              <p>Remove from other artefacts</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-built_in">Object</span>.entries(artefact).forEach(<span class="hljs-function">(<span class="hljs-params">[name, art]</span>) =&gt;</span> {

        <span class="hljs-keyword">if</span> (art.name !== myname) {

            <span class="hljs-keyword">let</span> state = art.state;

            <span class="hljs-keyword">if</span> (state) {

                <span class="hljs-keyword">let</span> fill = state.fillStyle,
                    stroke = state.strokeStyle;

                <span class="hljs-keyword">if</span> (fill.name &amp;&amp; fill.name === myname) state.fillStyle = state.defs.fillStyle;
                <span class="hljs-keyword">if</span> (stroke.name &amp;&amp; stroke.name === myname) state.strokeStyle = state.defs.strokeStyle;
            }
        }
    });</pre></div></div>
            
        </li>
        
        
        <li id="section-27">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-27">&#x00a7;</a>
              </div>
              <p>Kill group</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">if</span> (group[myname]) group[myname].kill();
};</pre></div></div>
            
        </li>
        
        
        <li id="section-28">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-28">&#x00a7;</a>
              </div>
              <h4 id="get-set-deltaset">Get, Set, deltaSet</h4>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-keyword">let</span> G = P.getters, 
    S = P.setters,
    D = P.deltaSetters;</pre></div></div>
            
        </li>
        
        
        <li id="section-29">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-29">&#x00a7;</a>
              </div>
              <p><code>get</code> - overwrites the mixin/position function</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>P.get = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">item</span>) </span>{

    <span class="hljs-keyword">let</span> getter = <span class="hljs-built_in">this</span>.getters[item];

    <span class="hljs-keyword">if</span> (getter) <span class="hljs-keyword">return</span> getter.call(<span class="hljs-built_in">this</span>);

    <span class="hljs-keyword">else</span> {

        <span class="hljs-keyword">let</span> def = <span class="hljs-built_in">this</span>.defs[item],
            state = <span class="hljs-built_in">this</span>.state,
            val;

        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> def != <span class="hljs-string">&#x27;undefined&#x27;</span>) {

            val = <span class="hljs-built_in">this</span>[item];
            <span class="hljs-keyword">return</span> (<span class="hljs-keyword">typeof</span> val != <span class="hljs-string">&#x27;undefined&#x27;</span>) ? val : def;
        }

        def = state.defs[item];

        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> def != <span class="hljs-string">&#x27;undefined&#x27;</span>) {

            val = state[item];
            <span class="hljs-keyword">return</span> (<span class="hljs-keyword">typeof</span> val != <span class="hljs-string">&#x27;undefined&#x27;</span>) ? val : def;
        }
        <span class="hljs-keyword">return</span> undef;
    }
};</pre></div></div>
            
        </li>
        
        
        <li id="section-30">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-30">&#x00a7;</a>
              </div>
              <p><code>width</code></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>G.width = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{

    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.currentDimensions[<span class="hljs-number">0</span>] || <span class="hljs-built_in">this</span>.element.getAttribute(<span class="hljs-string">&#x27;width&#x27;</span>);
};
S.width = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">item</span>) </span>{

    <span class="hljs-built_in">this</span>.dimensions[<span class="hljs-number">0</span>] = item;
    <span class="hljs-built_in">this</span>.dirtyDimensions = <span class="hljs-literal">true</span>;
};</pre></div></div>
            
        </li>
        
        
        <li id="section-31">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-31">&#x00a7;</a>
              </div>
              <p><code>height</code></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>G.height = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{

    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.currentDimensions[<span class="hljs-number">1</span>] || <span class="hljs-built_in">this</span>.element.getAttribute(<span class="hljs-string">&#x27;height&#x27;</span>);
};
S.height = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">item</span>) </span>{

    <span class="hljs-built_in">this</span>.dimensions[<span class="hljs-number">1</span>] = item;
    <span class="hljs-built_in">this</span>.dirtyDimensions = <span class="hljs-literal">true</span>;
};</pre></div></div>
            
        </li>
        
        
        <li id="section-32">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-32">&#x00a7;</a>
              </div>
              <p>Internal setters</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>S.source = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{};
S.engine = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">item</span>) </span>{};
S.state = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">item</span>) </span>{};

S.element = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">item</span>) </span>{

    <span class="hljs-keyword">if</span>(isa_canvas(item)) <span class="hljs-built_in">this</span>.installElement(item);
};</pre></div></div>
            
        </li>
        
        
        <li id="section-33">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-33">&#x00a7;</a>
              </div>
              <p>Display cycle Boolean flags <code>cleared</code>, <code>compiled</code>, <code>shown</code></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>S.backgroundColor = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">item</span>) </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-34">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-34">&#x00a7;</a>
              </div>
              <p>If we try to clear the cell with a transparent color, it will not clear. Setting it to an empty string fixes this issue</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">if</span> (<span class="hljs-string">&#x27;rgba(0, 0, 0, 0)&#x27;</span> === item || <span class="hljs-string">&#x27;transparent&#x27;</span> === item || <span class="hljs-string">&#x27;#00000000&#x27;</span> === item || <span class="hljs-string">&#x27;#0000&#x27;</span> === item) item = <span class="hljs-string">&#x27;&#x27;</span>;
    <span class="hljs-built_in">this</span>.backgroundColor = item;
};

S.cleared = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">item</span>) </span>{

    <span class="hljs-built_in">this</span>.cleared = item;
    <span class="hljs-built_in">this</span>.updateControllerCells();
};
S.compiled = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">item</span>) </span>{

    <span class="hljs-built_in">this</span>.compiled = item;
    <span class="hljs-built_in">this</span>.updateControllerCells();
};
S.shown = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">item</span>) </span>{

    <span class="hljs-built_in">this</span>.shown = item;
    <span class="hljs-built_in">this</span>.updateControllerCells();
};</pre></div></div>
            
        </li>
        
        
        <li id="section-35">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-35">&#x00a7;</a>
              </div>
              <p>Display cycle order attributes <code>compileOrder</code>, <code>showOrder</code> - argument should be a positive integer Number</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>S.compileOrder = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">item</span>) </span>{

    <span class="hljs-built_in">this</span>.compileOrder = item;
    <span class="hljs-built_in">this</span>.updateControllerCells();
};
S.showOrder = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">item</span>) </span>{

    <span class="hljs-built_in">this</span>.showOrder = item;
    <span class="hljs-built_in">this</span>.updateControllerCells();
};</pre></div></div>
            
        </li>
        
        
        <li id="section-36">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-36">&#x00a7;</a>
              </div>
              <p><strong>Stash coordinates and dimensions</strong> - which are stored in Coordinate arrays - allow us to store, and export to an image asset, a portion of the Cell’s current display which can then be used (for instance) by Pattern styles. </p>
<ul>
<li>Scrawl-canvas supplies the following <em>pseudo-attributes</em> for dealing with the stash start coordinate (<code>stashX</code>, <code>stashY</code>) and dimensions (<code>stashWidth</code>, <code>stashHeight</code>)</li>
<li>Each of these values can be either absolute px Numbers, or relative (to the Cell’s own dimensions) ‘%’ Strings</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>S.stashX = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">val</span>) </span>{

    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">this</span>.stashCoordinates) <span class="hljs-built_in">this</span>.stashCoordinates = [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>];
    <span class="hljs-built_in">this</span>.stashCoordinates[<span class="hljs-number">0</span>] = val;
};
S.stashY = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">val</span>) </span>{

    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">this</span>.stashCoordinates) <span class="hljs-built_in">this</span>.stashCoordinates = [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>];
    <span class="hljs-built_in">this</span>.stashCoordinates[<span class="hljs-number">1</span>] = val;
};
S.stashWidth = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">val</span>) </span>{

    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">this</span>.stashDimensions) {

        <span class="hljs-keyword">let</span> dims = <span class="hljs-built_in">this</span>.currentDimensions;
        <span class="hljs-built_in">this</span>.stashDimensions = [dims[<span class="hljs-number">0</span>], dims[<span class="hljs-number">1</span>]];
    }
    <span class="hljs-built_in">this</span>.stashDimensions[<span class="hljs-number">0</span>] = val;
};
S.stashHeight = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">val</span>) </span>{

    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">this</span>.stashDimensions) {

        <span class="hljs-keyword">let</span> dims = <span class="hljs-built_in">this</span>.currentDimensions;
        <span class="hljs-built_in">this</span>.stashDimensions = [dims[<span class="hljs-number">0</span>], dims[<span class="hljs-number">1</span>]];
    }
    <span class="hljs-built_in">this</span>.stashDimensions[<span class="hljs-number">1</span>] = val;
};
D.stashX = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">val</span>) </span>{

    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">this</span>.stashCoordinates) <span class="hljs-built_in">this</span>.stashCoordinates = [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>];

    <span class="hljs-keyword">let</span> c = <span class="hljs-built_in">this</span>.stashCoordinates;
    c[<span class="hljs-number">0</span>] = addStrings(c[<span class="hljs-number">0</span>], val);
};
D.stashY = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">val</span>) </span>{

    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">this</span>.stashCoordinates) <span class="hljs-built_in">this</span>.stashCoordinates = [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>];

    <span class="hljs-keyword">let</span> c = <span class="hljs-built_in">this</span>.stashCoordinates;
    c[<span class="hljs-number">1</span>] = addStrings(c[<span class="hljs-number">1</span>], val);
};
D.stashWidth = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">val</span>) </span>{

    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">this</span>.stashDimensions) {

        <span class="hljs-keyword">let</span> dims = <span class="hljs-built_in">this</span>.currentDimensions;
        <span class="hljs-built_in">this</span>.stashDimensions = [dims[<span class="hljs-number">0</span>], dims[<span class="hljs-number">1</span>]];
    }

    <span class="hljs-keyword">let</span> c = <span class="hljs-built_in">this</span>.stashDimensions;
    c[<span class="hljs-number">0</span>] = addStrings(c[<span class="hljs-number">0</span>], val);
};
D.stashHeight = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">val</span>) </span>{

    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">this</span>.stashDimensions) {

        <span class="hljs-keyword">let</span> dims = <span class="hljs-built_in">this</span>.currentDimensions;
        <span class="hljs-built_in">this</span>.stashDimensions = [dims[<span class="hljs-number">0</span>], dims[<span class="hljs-number">1</span>]];
    }

    <span class="hljs-keyword">let</span> c = <span class="hljs-built_in">this</span>.stashDimensions;
    c[<span class="hljs-number">1</span>] = addStrings(c[<span class="hljs-number">1</span>], val);
};

S.clearAlpha = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">val</span>) </span>{

    <span class="hljs-keyword">if</span> (val.toFixed) {

        <span class="hljs-keyword">if</span> (val &gt; <span class="hljs-number">1</span>) val = <span class="hljs-number">1</span>;
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (val &lt; <span class="hljs-number">0</span>) val = <span class="hljs-number">0</span>;

        <span class="hljs-built_in">this</span>.clearAlpha = val;
    }
};
D.clearAlpha = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">val</span>) </span>{

    <span class="hljs-keyword">if</span> (val.toFixed) {

        val += <span class="hljs-built_in">this</span>.clearAlpha;

        <span class="hljs-keyword">if</span> (val &gt; <span class="hljs-number">1</span>) val = <span class="hljs-number">1</span>;
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (val &lt; <span class="hljs-number">0</span>) val = <span class="hljs-number">0</span>;

        <span class="hljs-built_in">this</span>.clearAlpha = val;
    }
};</pre></div></div>
            
        </li>
        
        
        <li id="section-37">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-37">&#x00a7;</a>
              </div>
              <h4 id="prototype-functions">Prototype functions</h4>

            </div>
            
        </li>
        
        
        <li id="section-38">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-38">&#x00a7;</a>
              </div>
              <p><code>checkSource</code> - internal function</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>P.checkSource = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">width, height</span>) </span>{

    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.currentDimensions[<span class="hljs-number">0</span>] !== width || <span class="hljs-built_in">this</span>.currentDimensions[<span class="hljs-number">1</span>] !== height) <span class="hljs-built_in">this</span>.notifySubscribers();
};</pre></div></div>
            
        </li>
        
        
        <li id="section-39">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-39">&#x00a7;</a>
              </div>
              <p><code>getData</code> - internal function, invoked when a Cell wrapper is used as an entity’s pattern style</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>P.getData = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">entity, cell</span>) </span>{

    <span class="hljs-built_in">this</span>.checkSource(<span class="hljs-built_in">this</span>.sourceNaturalDimensions[<span class="hljs-number">0</span>], <span class="hljs-built_in">this</span>.sourceNaturalDimensions[<span class="hljs-number">1</span>]);

    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.buildStyle(cell);
};</pre></div></div>
            
        </li>
        
        
        <li id="section-40">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-40">&#x00a7;</a>
              </div>
              <p><code>updateArtefacts</code> - passes the <strong>items</strong> argument object through to each of the Cell’s Groups for forwarding to their artefacts’ <code>setDelta</code> function</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>P.updateArtefacts = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">items = Ωempty</span>) </span>{

    <span class="hljs-keyword">const</span> gb = <span class="hljs-built_in">this</span>.groupBuckets;

    <span class="hljs-keyword">let</span> art, ab, i, iz, j, jz;

    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>, iz = gb.length; i &lt; iz; i++) {

        ab = gb[i].artefactBuckets;

        <span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>, jz = ab.length; j &lt; jz; j++) {

            art = ab[j];

            <span class="hljs-keyword">if</span> (items.dirtyScale) art.dirtyScale = <span class="hljs-literal">true</span>;
            <span class="hljs-keyword">if</span> (items.dirtyDimensions) art.dirtyDimensions = <span class="hljs-literal">true</span>;
            <span class="hljs-keyword">if</span> (items.dirtyLock) art.dirtyLock = <span class="hljs-literal">true</span>;
            <span class="hljs-keyword">if</span> (items.dirtyStart) art.dirtyStart = <span class="hljs-literal">true</span>;
            <span class="hljs-keyword">if</span> (items.dirtyOffset) art.dirtyOffset = <span class="hljs-literal">true</span>;
            <span class="hljs-keyword">if</span> (items.dirtyHandle) art.dirtyHandle = <span class="hljs-literal">true</span>;
            <span class="hljs-keyword">if</span> (items.dirtyRotation) art.dirtyRotation = <span class="hljs-literal">true</span>;
            <span class="hljs-keyword">if</span> (items.dirtyPathObject) art.dirtyPathObject = <span class="hljs-literal">true</span>;
        }
    }
};</pre></div></div>
            
        </li>
        
        
        <li id="section-41">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-41">&#x00a7;</a>
              </div>
              <p><code>cleanDimensionsAdditionalActions</code> - overwrites mixin/position function:</p>
<ul>
<li>Updates the Cell’s &lt;canvas&gt; element’s dimensions</li>
<li>Restores the render engine’s attributes to current cell values (because the resize wipes them to default values)</li>
<li>Asks the Canvas controller to trigger an update to the Cell’s <code>here</code> object</li>
<li>Tells all associated artefacts that the Cell’s dimensions have changed</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>P.cleanDimensionsAdditionalActions = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{

    <span class="hljs-keyword">let</span> element = <span class="hljs-built_in">this</span>.element;

    <span class="hljs-keyword">if</span> (element) {

        <span class="hljs-keyword">let</span> control = <span class="hljs-built_in">this</span>.controller,
            current = <span class="hljs-built_in">this</span>.currentDimensions,
            base = <span class="hljs-built_in">this</span>.isBase;</pre></div></div>
            
        </li>
        
        
        <li id="section-42">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-42">&#x00a7;</a>
              </div>
              <p>DEPRECATED (because it is a really bad name) <strong>isComponent</strong> replaced by <strong>baseMatchesCanvasDimensions</strong></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (base &amp;&amp; control &amp;&amp; (control.baseMatchesCanvasDimensions || control.isComponent)) {

            <span class="hljs-keyword">let</span> controlDims = <span class="hljs-built_in">this</span>.controller.currentDimensions,
                dims = <span class="hljs-built_in">this</span>.dimensions;

            dims[<span class="hljs-number">0</span>] = current[<span class="hljs-number">0</span>] = controlDims[<span class="hljs-number">0</span>];
            dims[<span class="hljs-number">1</span>] = current[<span class="hljs-number">1</span>] = controlDims[<span class="hljs-number">1</span>];
        }

        <span class="hljs-keyword">let</span> [w, h] = current;

        element.width = w;
        element.height = h;

        <span class="hljs-built_in">this</span>.setEngineFromState(<span class="hljs-built_in">this</span>.engine);

        <span class="hljs-keyword">if</span> (base &amp;&amp; control) control.updateBaseHere();

        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.groupBuckets) {

            <span class="hljs-built_in">this</span>.updateArtefacts({
                <span class="hljs-attr">dirtyDimensions</span>: <span class="hljs-literal">true</span>,
            });
        }
    }
};</pre></div></div>
            
        </li>
        
        
        <li id="section-43">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-43">&#x00a7;</a>
              </div>
              <p><code>notifySubscriber</code> - Overrides mixin/asset.js function</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>P.notifySubscriber = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">sub</span>) </span>{

    <span class="hljs-keyword">if</span> (!sub.sourceNaturalDimensions) sub.sourceNaturalDimensions = [];

    sub.sourceNaturalWidth = <span class="hljs-built_in">this</span>.currentDimensions[<span class="hljs-number">0</span>];
    sub.sourceNaturalHeight = <span class="hljs-built_in">this</span>.currentDimensions[<span class="hljs-number">1</span>];

    sub.sourceLoaded = <span class="hljs-literal">true</span>;
    sub.dirtyImage = <span class="hljs-literal">true</span>;

    sub.dirtyCopyStart = <span class="hljs-literal">true</span>;
    sub.dirtyCopyDimensions = <span class="hljs-literal">true</span>;
};</pre></div></div>
            
        </li>
        
        
        <li id="section-44">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-44">&#x00a7;</a>
              </div>
              <p><code>subscribeAction</code> - Overrides mixin/asset.js function</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>P.subscribeAction = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">sub = {}</span>) </span>{

    <span class="hljs-built_in">this</span>.subscribers.push(sub);
    sub.asset = <span class="hljs-built_in">this</span>;
    sub.source = <span class="hljs-built_in">this</span>.element;
    <span class="hljs-built_in">this</span>.notifySubscriber(sub)
};</pre></div></div>
            
        </li>
        
        
        <li id="section-45">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-45">&#x00a7;</a>
              </div>
              <p><code>installElement</code> - internal function, used by the constructor</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>P.installElement = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">element</span>) </span>{

    <span class="hljs-built_in">this</span>.element = element;
    <span class="hljs-built_in">this</span>.engine = <span class="hljs-built_in">this</span>.element.getContext(<span class="hljs-string">&#x27;2d&#x27;</span>, {<span class="hljs-attr">willReadFrequently</span>: <span class="hljs-literal">true</span>});

    <span class="hljs-built_in">this</span>.state = makeState({
        <span class="hljs-attr">engine</span>: <span class="hljs-built_in">this</span>.engine
    });

    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;
};</pre></div></div>
            
        </li>
        
        
        <li id="section-46">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-46">&#x00a7;</a>
              </div>
              <p><code>updateControllerCells</code> - internal function: ask the Cell’s Canvas controller to review/update its cells data</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>P.updateControllerCells = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{

    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.controller) <span class="hljs-built_in">this</span>.controller.dirtyCells = <span class="hljs-literal">true</span>;
};</pre></div></div>
            
        </li>
        
        
        <li id="section-47">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-47">&#x00a7;</a>
              </div>
              <p>The following functions set the Cell wrapper’s &lt;canvas&gt; element’s CanvasRenderingContext2D engine’s attributes to match a given set of values</p>

            </div>
            
        </li>
        
        
        <li id="section-48">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-48">&#x00a7;</a>
              </div>
              <p><code>setEngineFromState</code> - internal function: set engine to match this Cell’s State object’s attribute values</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>P.setEngineFromState = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">engine</span>) </span>{

    <span class="hljs-keyword">const</span> state = <span class="hljs-built_in">this</span>.state,
        stateKeys = state.allKeys,
        stateKeysLen = stateKeys.length;

    <span class="hljs-keyword">let</span> i, iz, key, eVal, sVal;

    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; stateKeysLen; i++) {

        key = stateKeys[i];
        eVal = engine[key];
        sVal = state[key];

        <span class="hljs-keyword">if</span> (key === <span class="hljs-string">&#x27;lineDash&#x27;</span>) {

            engine.lineDash = sVal;
            engine.setLineDash(engine.lineDash);
        }
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (eVal !== sVal) engine[key] = sVal;
    }
    <span class="hljs-keyword">if</span> (engine.textAlign !== <span class="hljs-string">&#x27;left&#x27;</span>) engine.textAlign = <span class="hljs-string">&#x27;left&#x27;</span>;
    <span class="hljs-keyword">if</span> (engine.textBaseline !== <span class="hljs-string">&#x27;top&#x27;</span>) engine.textBaseline = <span class="hljs-string">&#x27;top&#x27;</span>;

    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;
};</pre></div></div>
            
        </li>
        
        
        <li id="section-49">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-49">&#x00a7;</a>
              </div>
              <p><code>setToDefaults</code> - internal function: set engine to match the State Factory’s default attribute values</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>P.setToDefaults = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{

    <span class="hljs-keyword">let</span> items = <span class="hljs-built_in">this</span>.state.defs,
        state = <span class="hljs-built_in">this</span>.state,
        engine = <span class="hljs-built_in">this</span>.engine,
        isArray = <span class="hljs-built_in">Array</span>.isArray;

    <span class="hljs-built_in">Object</span>.entries(items).forEach(<span class="hljs-function">(<span class="hljs-params">[key, value]</span>) =&gt;</span> {

        <span class="hljs-keyword">if</span> (key === <span class="hljs-string">&#x27;lineDash&#x27;</span>) {

            <span class="hljs-keyword">if</span> (!isArray(engine.lineDash)) engine.lineDash = [];
            <span class="hljs-keyword">else</span> engine.lineDash.length = <span class="hljs-number">0</span>;

            <span class="hljs-keyword">if</span> (!isArray(state.lineDash)) state.lineDash = [];
            <span class="hljs-keyword">else</span> state.lineDash.length = <span class="hljs-number">0</span>;
        }
        <span class="hljs-keyword">else</span> {

            engine[key] = value;
            state[key] = value;
        }
    });

    engine.textAlign = state.textAlign = <span class="hljs-string">&#x27;left&#x27;</span>;
    engine.textBaseline = state.textBaseline = <span class="hljs-string">&#x27;top&#x27;</span>;

    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;
};</pre></div></div>
            
        </li>
        
        
        <li id="section-50">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-50">&#x00a7;</a>
              </div>
              <p><code>setEngine</code> - internal function: set engine to match the entity object’s State attribute values</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>P.stylesArray = [<span class="hljs-string">&#x27;Gradient&#x27;</span>, <span class="hljs-string">&#x27;RadialGradient&#x27;</span>, <span class="hljs-string">&#x27;Pattern&#x27;</span>];
P.setEngine = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">entity</span>) </span>{

    <span class="hljs-keyword">const</span> state = <span class="hljs-built_in">this</span>.state,
        entityState = entity.state;

    <span class="hljs-keyword">if</span> (entityState) {

        <span class="hljs-keyword">let</span> engine, item,
            changes = entityState.getChanges(entity, state),
            action = <span class="hljs-built_in">this</span>.setEngineActions,
            stylesArray = <span class="hljs-built_in">this</span>.stylesArray;

        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Object</span>.keys(changes).length) {

            engine = <span class="hljs-built_in">this</span>.engine;

            <span class="hljs-keyword">for</span> (item <span class="hljs-keyword">in</span> changes) {

                action[item](changes[item], engine, stylesArray, entity, <span class="hljs-built_in">this</span>);
                state[item] = changes[item];
            }
        }
    }
    <span class="hljs-keyword">return</span> entity;
};</pre></div></div>
            
        </li>
        
        
        <li id="section-51">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-51">&#x00a7;</a>
              </div>
              <p><strong>setEngineActions</strong> - an Object containing functions for updating the engine’s attributes; used by <code>setEngine</code></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>P.setEngineActions = {

    <span class="hljs-attr">fillStyle</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">item, engine, stylesArray, entity, layer</span>) </span>{

        <span class="hljs-keyword">if</span> (item.substring) {

            <span class="hljs-keyword">let</span> brokenStyle = <span class="hljs-literal">false</span>;

            <span class="hljs-keyword">if</span> (stylesnames.indexOf(item) &gt;= <span class="hljs-number">0</span>) brokenStyle = styles[item];
            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cellnames.indexOf(item) &gt;= <span class="hljs-number">0</span>) brokenStyle = cell[item];

            <span class="hljs-keyword">if</span> (brokenStyle) {
                
                entity.state.fillStyle = brokenStyle;
                engine.fillStyle = brokenStyle.getData(entity, layer);
            }
            <span class="hljs-keyword">else</span> engine.fillStyle = item;
        }
        <span class="hljs-keyword">else</span> engine.fillStyle = item.getData(entity, layer);
    },

    <span class="hljs-attr">filter</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">item, engine</span>) </span>{
        engine.filter = item;
    },

    <span class="hljs-attr">font</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">item, engine</span>) </span>{
        engine.font = item;
    },

    <span class="hljs-attr">globalAlpha</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">item, engine</span>) </span>{
        engine.globalAlpha = item;
    },

    <span class="hljs-attr">globalCompositeOperation</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">item, engine</span>) </span>{
        engine.globalCompositeOperation = item;
    },

    <span class="hljs-attr">lineCap</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">item, engine</span>) </span>{
        engine.lineCap = item;
    },

    <span class="hljs-attr">lineDash</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">item, engine</span>) </span>{
        engine.lineDash = item;
        <span class="hljs-keyword">if</span> (engine.setLineDash) engine.setLineDash(item);
    },

    <span class="hljs-attr">lineDashOffset</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">item, engine</span>) </span>{
        engine.lineDashOffset = item;
    },

    <span class="hljs-attr">lineJoin</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">item, engine</span>) </span>{
        engine.lineJoin = item;
    },

    <span class="hljs-attr">lineWidth</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">item, engine</span>) </span>{
        engine.lineWidth = item;
    },

    <span class="hljs-attr">miterLimit</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">item, engine</span>) </span>{
        engine.miterLimit = item;
    },

    <span class="hljs-attr">shadowBlur</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">item, engine</span>) </span>{
        engine.shadowBlur = item;
    },

    <span class="hljs-attr">shadowColor</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">item, engine</span>) </span>{
        engine.shadowColor = item;
    },

    <span class="hljs-attr">shadowOffsetX</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">item, engine</span>) </span>{
        engine.shadowOffsetX = item;
    },

    <span class="hljs-attr">shadowOffsetY</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">item, engine</span>) </span>{
        engine.shadowOffsetY = item;
    },

    <span class="hljs-attr">strokeStyle</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">item, engine, stylesArray, entity, layer</span>) </span>{

        <span class="hljs-keyword">if</span> (item.substring) {

            <span class="hljs-keyword">let</span> brokenStyle = <span class="hljs-literal">false</span>;

            <span class="hljs-keyword">if</span> (stylesnames.indexOf(item) &gt;= <span class="hljs-number">0</span>) brokenStyle = styles[item];
            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cellnames.indexOf(item) &gt;= <span class="hljs-number">0</span>) brokenStyle = cell[item];

            <span class="hljs-keyword">if</span> (brokenStyle) {
                
                entity.state.strokeStyle = brokenStyle;
                engine.strokeStyle = brokenStyle.getData(entity, layer);
            }
            <span class="hljs-keyword">else</span> engine.strokeStyle = item;
        }
        <span class="hljs-keyword">else</span> engine.strokeStyle = item.getData(entity, layer);
    },
};</pre></div></div>
            
        </li>
        
        
        <li id="section-52">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-52">&#x00a7;</a>
              </div>
              <p>The following functions are used as part of entity object <code>stamp</code> functionality - specifically for those with a <strong>method</strong> whose appearance is affected by shadows, and for the <code>clear</code> method</p>
<ul>
<li>Scrawl-canvas, for the most part, avoids using engine.save() and engine.restore() functionality, instead preferring to keep track of engine state in State objects. </li>
<li>When clearing and restoring shadows - a frequent operation given Scrawl-canvas functionality around stamping methods - both the Cell’s state object and the Canvas context engine need to be updated with the necessary data </li>
<li>The same reasoning holds when setting up the context engine to ‘clear’ an entity from the canvas display instead of stamping it onto the canvas</li>
</ul>

            </div>
            
        </li>
        
        
        <li id="section-53">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-53">&#x00a7;</a>
              </div>
              <p><code>clearShadow</code></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>P.clearShadow = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{

    <span class="hljs-built_in">this</span>.engine.shadowOffsetX = <span class="hljs-number">0.0</span>;
    <span class="hljs-built_in">this</span>.engine.shadowOffsetY = <span class="hljs-number">0.0</span>;
    <span class="hljs-built_in">this</span>.engine.shadowBlur = <span class="hljs-number">0.0</span>;
    <span class="hljs-built_in">this</span>.state.shadowOffsetX = <span class="hljs-number">0.0</span>;
    <span class="hljs-built_in">this</span>.state.shadowOffsetY = <span class="hljs-number">0.0</span>;
    <span class="hljs-built_in">this</span>.state.shadowBlur = <span class="hljs-number">0.0</span>;

    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;
};</pre></div></div>
            
        </li>
        
        
        <li id="section-54">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-54">&#x00a7;</a>
              </div>
              <p><code>restoreShadow</code></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>P.restoreShadow = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">entity</span>) </span>{

    <span class="hljs-keyword">let</span> state = entity.state;

    <span class="hljs-built_in">this</span>.engine.shadowOffsetX = state.shadowOffsetX;
    <span class="hljs-built_in">this</span>.engine.shadowOffsetY = state.shadowOffsetY;
    <span class="hljs-built_in">this</span>.engine.shadowBlur = state.shadowBlur;
    <span class="hljs-built_in">this</span>.state.shadowOffsetX = state.shadowOffsetX;
    <span class="hljs-built_in">this</span>.state.shadowOffsetY = state.shadowOffsetY;
    <span class="hljs-built_in">this</span>.state.shadowBlur = state.shadowBlur;

    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;
};</pre></div></div>
            
        </li>
        
        
        <li id="section-55">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-55">&#x00a7;</a>
              </div>
              <p><code>setToClearShape</code></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>P.setToClearShape = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{

    <span class="hljs-built_in">this</span>.engine.fillStyle = <span class="hljs-string">&#x27;rgba(0,0,0,0)&#x27;</span>;
    <span class="hljs-built_in">this</span>.engine.strokeStyle = <span class="hljs-string">&#x27;rgba(0,0,0,0)&#x27;</span>;
    <span class="hljs-built_in">this</span>.engine.shadowColor = <span class="hljs-string">&#x27;rgba(0,0,0,0)&#x27;</span>;
    <span class="hljs-built_in">this</span>.state.fillStyle = <span class="hljs-string">&#x27;rgba(0,0,0,0)&#x27;</span>;
    <span class="hljs-built_in">this</span>.state.strokeStyle = <span class="hljs-string">&#x27;rgba(0,0,0,0)&#x27;</span>;
    <span class="hljs-built_in">this</span>.state.shadowColor = <span class="hljs-string">&#x27;rgba(0,0,0,0)&#x27;</span>;

    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;
};</pre></div></div>
            
        </li>
        
        
        <li id="section-56">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-56">&#x00a7;</a>
              </div>
              <p><code>saveEngine</code>, <code>restoreEngine</code> - save and restore the Cell wrapper’s &lt;canvas&gt; element’s CanvasRenderingContext2D engine’s current state to/from a stack</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>P.saveEngine = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{

    <span class="hljs-built_in">this</span>.engine.save();
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;
};

P.restoreEngine = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{

    <span class="hljs-built_in">this</span>.engine.restore();
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;
};</pre></div></div>
            
        </li>
        
        
        <li id="section-57">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-57">&#x00a7;</a>
              </div>
              <p><code>getComputedFontSizes</code> - internal function - the Cell wrapper gets passed by Phrase entitys to its fontAttributes object, which then invokes it when calculating font sizes</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>P.getComputedFontSizes = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{

    <span class="hljs-keyword">let</span> host = <span class="hljs-built_in">this</span>.getHost();

    <span class="hljs-keyword">if</span> (host &amp;&amp; host.domElement) {

        <span class="hljs-keyword">let</span> em = <span class="hljs-built_in">window</span>.getComputedStyle(host.domElement),
            rem = <span class="hljs-built_in">window</span>.getComputedStyle(<span class="hljs-built_in">document</span>.documentElement);

        <span class="hljs-keyword">return</span> [<span class="hljs-built_in">parseFloat</span>(em.fontSize), <span class="hljs-built_in">parseFloat</span>(rem.fontSize), <span class="hljs-built_in">window</span>.innerWidth, <span class="hljs-built_in">window</span>.innerHeight];
    }
    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
}</pre></div></div>
            
        </li>
        
        
        <li id="section-58">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-58">&#x00a7;</a>
              </div>
              <h4 id="display-cycle-functionality">Display cycle functionality</h4>
<p>This functionality is triggered by the Cell’s Canvas wrapper controller</p>

            </div>
            
        </li>
        
        
        <li id="section-59">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-59">&#x00a7;</a>
              </div>
              <p><code>clear</code></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>P.clear = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{

    <span class="hljs-keyword">const</span> {element, engine, backgroundColor, clearAlpha, currentDimensions} = <span class="hljs-built_in">this</span>;
    <span class="hljs-keyword">const</span> [width, height] = currentDimensions;

    <span class="hljs-built_in">this</span>.prepareStamp();

    engine.setTransform(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);

    <span class="hljs-keyword">if</span> (backgroundColor) {

        <span class="hljs-keyword">let</span> tempBackground = engine.fillStyle,
            tempGCO = engine.globalCompositeOperation,
            tempAlpha = engine.globalAlpha;

        engine.fillStyle = backgroundColor;
        engine.globalCompositeOperation = <span class="hljs-string">&#x27;source-over&#x27;</span>;
        engine.globalAlpha = <span class="hljs-number">1</span>;
        engine.fillRect(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, width, height);
        engine.fillStyle = tempBackground;
        engine.globalCompositeOperation = tempGCO;
        engine.globalAlpha = tempAlpha;
    }
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (clearAlpha) {

        <span class="hljs-keyword">let</span> tempCell = requestCell();
        
        <span class="hljs-keyword">let</span> {<span class="hljs-attr">engine</span>:tempEngine, <span class="hljs-attr">element</span>:tempEl} = tempCell;

        tempEl.width = width;
        tempEl.height = height;

        <span class="hljs-keyword">let</span> data = engine.getImageData(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, width, height);
        tempEngine.putImageData(data, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);

        <span class="hljs-keyword">let</span> oldAlpha = engine.globalAlpha;

        engine.clearRect(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, width, height);
        engine.globalAlpha = clearAlpha;
        engine.drawImage(tempEl, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);
        engine.globalAlpha = oldAlpha;
    }
    <span class="hljs-keyword">else</span> engine.clearRect(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, width, height);
};</pre></div></div>
            
        </li>
        
        
        <li id="section-60">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-60">&#x00a7;</a>
              </div>
              <p><code>compile</code></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>P.compile = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{

    <span class="hljs-keyword">let</span> mystash = <span class="hljs-built_in">this</span>.stashOutput;

    <span class="hljs-built_in">this</span>.sortGroups();
    <span class="hljs-built_in">this</span>.prepareStamp();

    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span>.dirtyFilters || !<span class="hljs-built_in">this</span>.currentFilters) <span class="hljs-built_in">this</span>.cleanFilters();

    <span class="hljs-keyword">const</span> gb = <span class="hljs-built_in">this</span>.groupBuckets,
        gbLen = gb.length;

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>, grp; i &lt; gbLen; i++) {

        grp = gb[i];
        <span class="hljs-keyword">if</span> (grp &amp;&amp; grp.stamp) grp.stamp();
    }

    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">this</span>.noFilters &amp;&amp; <span class="hljs-built_in">this</span>.filters &amp;&amp; <span class="hljs-built_in">this</span>.filters.length) <span class="hljs-built_in">this</span>.applyFilters();
    <span class="hljs-built_in">this</span>.stashOutputAction();
};</pre></div></div>
            
        </li>
        
        
        <li id="section-61">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-61">&#x00a7;</a>
              </div>
              <p><code>show</code> - Note that functionality here differs for <strong>base cells</strong> and other Cell wrappers</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>P.show = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-62">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-62">&#x00a7;</a>
              </div>
              <p>get the destination cell’s canvas context</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">let</span> host = <span class="hljs-built_in">this</span>.getHost(),
        engine = (host &amp;&amp; host.engine) ? host.engine : <span class="hljs-literal">false</span>;

    <span class="hljs-keyword">if</span> (engine) {

        <span class="hljs-keyword">let</span> floor = <span class="hljs-built_in">Math</span>.floor,
            hostDimensions = host.currentDimensions,
            destWidth = floor(hostDimensions[<span class="hljs-number">0</span>]),
            destHeight = floor(hostDimensions[<span class="hljs-number">1</span>]);</pre></div></div>
            
        </li>
        
        
        <li id="section-63">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-63">&#x00a7;</a>
              </div>
              <p>Cannot draw to the destination canvas if either of its dimensions === 0</p>
<ul>
<li>Test on Demo component-002</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (!destWidth || !destHeight) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;

        <span class="hljs-keyword">let</span> { <span class="hljs-attr">currentScale</span>:scale, currentDimensions, composite, alpha, controller, element, isBase, <span class="hljs-attr">currentStampHandlePosition</span>:handle, <span class="hljs-attr">currentStampPosition</span>:stamp } = <span class="hljs-built_in">this</span>;

        <span class="hljs-keyword">let</span> curWidth = floor(currentDimensions[<span class="hljs-number">0</span>]),
            curHeight = floor(currentDimensions[<span class="hljs-number">1</span>]),
            paste;

        engine.save();
        engine.setTransform(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);
            
        engine.filter = <span class="hljs-built_in">this</span>.filter;

        <span class="hljs-keyword">if</span> (isBase) {

            <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">this</span>.basePaste) <span class="hljs-built_in">this</span>.basePaste = [];
            paste = <span class="hljs-built_in">this</span>.basePaste;</pre></div></div>
            
        </li>
        
        
        <li id="section-64">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-64">&#x00a7;</a>
              </div>
              <p>copy the base canvas over to the display canvas. This copy operation ignores any scale, roll or position attributes set on the base cell, instead complying with the controller’s fit attribute requirements</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-built_in">this</span>.prepareStamp();

            engine.globalCompositeOperation = <span class="hljs-string">&#x27;source-over&#x27;</span>;
            engine.globalAlpha = <span class="hljs-number">1</span>;
            engine.clearRect(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, destWidth, destHeight);

            engine.globalCompositeOperation = composite;
            engine.globalAlpha = alpha;

            <span class="hljs-keyword">let</span> fit = (controller) ? controller.fit : <span class="hljs-string">&#x27;none&#x27;</span>,
                relWidth, relHeight;

            <span class="hljs-keyword">switch</span> (fit) {

                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;contain&#x27;</span> :</pre></div></div>
            
        </li>
        
        
        <li id="section-65">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-65">&#x00a7;</a>
              </div>
              <p>base must copy into display resized, centered, letterboxing if necessary, maintaining aspect ratio</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                    relWidth = destWidth / (curWidth || <span class="hljs-number">1</span>);
                    relHeight = destHeight / (curHeight || <span class="hljs-number">1</span>);

                    <span class="hljs-keyword">if</span> (relWidth &gt; relHeight) {

                        paste[<span class="hljs-number">0</span>] = floor((destWidth - (curWidth * relHeight)) / <span class="hljs-number">2</span>);
                        paste[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;
                        paste[<span class="hljs-number">2</span>] = floor(curWidth * relHeight);
                        paste[<span class="hljs-number">3</span>] = floor(curHeight * relHeight);
                    }
                    <span class="hljs-keyword">else</span> {

                        paste[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;
                        paste[<span class="hljs-number">1</span>] = floor((destHeight - (curHeight * relWidth)) / <span class="hljs-number">2</span>);
                        paste[<span class="hljs-number">2</span>] = floor(curWidth * relWidth);
                        paste[<span class="hljs-number">3</span>] = floor(curHeight * relWidth);
                    }
                    <span class="hljs-keyword">break</span>;

                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;cover&#x27;</span> :</pre></div></div>
            
        </li>
        
        
        <li id="section-66">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-66">&#x00a7;</a>
              </div>
              <p>base must copy into display resized, centered, leaving no letterbox area, maintaining aspect ratio</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                    relWidth = destWidth / (curWidth || <span class="hljs-number">1</span>);
                    relHeight = destHeight / (curHeight || <span class="hljs-number">1</span>);

                    <span class="hljs-keyword">if</span> (relWidth &lt; relHeight) {

                        paste[<span class="hljs-number">0</span>] = floor((destWidth - (curWidth * relHeight)) / <span class="hljs-number">2</span>);
                        paste[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;
                        paste[<span class="hljs-number">2</span>] = floor(curWidth * relHeight);
                        paste[<span class="hljs-number">3</span>] = floor(curHeight * relHeight);
                    }
                    <span class="hljs-keyword">else</span>{

                        paste[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;
                        paste[<span class="hljs-number">1</span>] = floor((destHeight - (curHeight * relWidth)) / <span class="hljs-number">2</span>);
                        paste[<span class="hljs-number">2</span>] = floor(curWidth * relWidth);
                        paste[<span class="hljs-number">3</span>] = floor(curHeight * relWidth);
                    }
                    <span class="hljs-keyword">break</span>;

                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;fill&#x27;</span> :</pre></div></div>
            
        </li>
        
        
        <li id="section-67">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-67">&#x00a7;</a>
              </div>
              <p>base must copy into display resized, distorting the aspect ratio as necessary</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                    paste[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;
                    paste[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;
                    paste[<span class="hljs-number">2</span>] = floor(destWidth);
                    paste[<span class="hljs-number">3</span>] = floor(destHeight);
                    <span class="hljs-keyword">break</span>;

                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;none&#x27;</span> :
                <span class="hljs-keyword">default</span> :</pre></div></div>
            
        </li>
        
        
        <li id="section-68">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-68">&#x00a7;</a>
              </div>
              <p>base copies into display as-is, centred, maintaining aspect ratio</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                    paste[<span class="hljs-number">0</span>] = floor((destWidth - curWidth) / <span class="hljs-number">2</span>);
                    paste[<span class="hljs-number">1</span>] = floor((destHeight - curHeight) / <span class="hljs-number">2</span>);
                    paste[<span class="hljs-number">2</span>] = curWidth;
                    paste[<span class="hljs-number">3</span>] = curHeight;
            }
        }
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (scale &gt; <span class="hljs-number">0</span>) {

            <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">this</span>.paste) <span class="hljs-built_in">this</span>.paste = [];
            paste = <span class="hljs-built_in">this</span>.paste;</pre></div></div>
            
        </li>
        
        
        <li id="section-69">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-69">&#x00a7;</a>
              </div>
              <p>Cell canvases are treated like entitys on the base canvas: they can be positioned, scaled and rotated. Positioning will respect lockTo; flipReverse and flipUpend; and can be pivoted to other artefacts, or follow a path entity, etc. If pivoted to the mouse, they will use the base canvas’s .here attribute, which takes into account differences between the base and display canvas dimensions.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
            <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">this</span>.noDeltaUpdates) <span class="hljs-built_in">this</span>.setDelta(<span class="hljs-built_in">this</span>.delta);

            <span class="hljs-built_in">this</span>.prepareStamp();

            engine.globalCompositeOperation = composite;
            engine.globalAlpha = alpha;

            paste[<span class="hljs-number">0</span>] = floor(-handle[<span class="hljs-number">0</span>] * scale);
            paste[<span class="hljs-number">1</span>] = floor(-handle[<span class="hljs-number">1</span>] * scale);
            paste[<span class="hljs-number">2</span>] = floor(curWidth * scale);
            paste[<span class="hljs-number">3</span>] = floor(curHeight * scale);

            <span class="hljs-built_in">this</span>.rotateDestination(engine, ...stamp);
        }
        engine.drawImage(element, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, curWidth, curHeight, ...paste);
        engine.restore();
    }
};</pre></div></div>
            
        </li>
        
        
        <li id="section-70">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-70">&#x00a7;</a>
              </div>
              <p><code>applyFilters</code> - Internal function - add filters to the Cell’s current output.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>P.applyFilters = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{

    <span class="hljs-keyword">let</span> engine = <span class="hljs-built_in">this</span>.engine;

    <span class="hljs-keyword">let</span> image = engine.getImageData(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-built_in">this</span>.currentDimensions[<span class="hljs-number">0</span>], <span class="hljs-built_in">this</span>.currentDimensions[<span class="hljs-number">1</span>]);

    <span class="hljs-built_in">this</span>.preprocessFilters(<span class="hljs-built_in">this</span>.currentFilters);

    <span class="hljs-keyword">let</span> img = filterEngine.action({
        <span class="hljs-attr">image</span>: image,
        <span class="hljs-attr">filters</span>: <span class="hljs-built_in">this</span>.currentFilters
    });

    <span class="hljs-keyword">if</span> (img) engine.putImageData(img, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);
};</pre></div></div>
            
        </li>
        
        
        <li id="section-71">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-71">&#x00a7;</a>
              </div>
              <p><code>stashOutputAction</code> - Internal function - stash the Cell’s current output. While this function can be called at any time, the simplest way to invoke it is to set the Cell’s <strong>stashOutput</strong> flag to true, which will then invoke this function at the end of the compile step of the Display cycle (after any filters have been applied to the cell display).</p>
<ul>
<li>The simplest way to set the stashOutput flag is to call <code>scrawl.createImageFromCell(cellName_or_cellObject, stashOutputAsAsset_flag)</code> from the user code.</li>
<li>We can limit the area of the cell display to be stashed by setting the Cell’s <strong>stashX</strong>, <strong>stashY</strong>, <strong>stashWidth</strong> and <strong>stashHeight</strong> values appropriately. These can all be either absolute (positive) number values, or %String number values relative to the Cell element’s dimensions.</li>
<li>We store the generated imageData object into the Cell object’s <strong>stashedImageData</strong> attribute.</li>
<li>If we are also stashing an image, an &lt;img&gt; element will be generated and stored in the Cell object’s <strong>stashedImage</strong> attribute. We also generate an imageAsset wrapper for the object that will have the name <code>cellname+&#39;-image&#39;</code>, which gets added to the assets section of the Scrawl-canvas library.</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>P.stashOutputAction = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{

    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.stashOutput) {

        <span class="hljs-built_in">this</span>.stashOutput = <span class="hljs-literal">false</span>;

        <span class="hljs-keyword">let</span> { currentDimensions, stashCoordinates, stashDimensions, engine } = <span class="hljs-built_in">this</span>;

        <span class="hljs-keyword">let</span> [cellWidth, cellHeight] = currentDimensions;

        <span class="hljs-keyword">let</span> stashX = (stashCoordinates) ? stashCoordinates[<span class="hljs-number">0</span>] : <span class="hljs-number">0</span>, 
            stashY = (stashCoordinates) ? stashCoordinates[<span class="hljs-number">1</span>] : <span class="hljs-number">0</span>, 
            stashWidth = (stashDimensions) ? stashDimensions[<span class="hljs-number">0</span>] : cellWidth, 
            stashHeight = (stashDimensions) ? stashDimensions[<span class="hljs-number">1</span>] : cellHeight;</pre></div></div>
            
        </li>
        
        
        <li id="section-72">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-72">&#x00a7;</a>
              </div>
              <p>Keep the stashed image within bounds of the Cell’s dimensions.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (stashWidth.substring || stashHeight.substring || stashX.substring || stashY.substring || stashX || stashY || stashWidth !== cellWidth || stashHeight !== cellHeight) {

            <span class="hljs-keyword">if</span> (stashWidth.substring) stashWidth = (<span class="hljs-built_in">parseFloat</span>(stashWidth) / <span class="hljs-number">100</span>) * cellWidth;
            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isNaN</span>(stashWidth) || stashWidth &lt;= <span class="hljs-number">0</span>) stashWidth = <span class="hljs-number">1</span>;
            <span class="hljs-keyword">if</span> (stashWidth &gt; cellWidth) stashWidth = cellWidth;

            <span class="hljs-keyword">if</span> (stashHeight.substring) stashHeight = (<span class="hljs-built_in">parseFloat</span>(stashHeight) / <span class="hljs-number">100</span>) * cellHeight;
            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isNaN</span>(stashHeight) || stashHeight &lt;= <span class="hljs-number">0</span>) stashHeight = <span class="hljs-number">1</span>;
            <span class="hljs-keyword">if</span> (stashHeight &gt; cellHeight) stashHeight = cellHeight;

            <span class="hljs-keyword">if</span> (stashX.substring) stashX = (<span class="hljs-built_in">parseFloat</span>(stashX) / <span class="hljs-number">100</span>) * cellWidth;
            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isNaN</span>(stashX) || stashX &lt; <span class="hljs-number">0</span>) stashX = <span class="hljs-number">0</span>;
            <span class="hljs-keyword">if</span> (stashX + stashWidth &gt; cellWidth) stashX = cellWidth - stashWidth;

            <span class="hljs-keyword">if</span> (stashY.substring) stashY = (<span class="hljs-built_in">parseFloat</span>(stashY) / <span class="hljs-number">100</span>) * cellHeight;
            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isNaN</span>(stashY) || stashY &lt; <span class="hljs-number">0</span>) stashY = <span class="hljs-number">0</span>;
            <span class="hljs-keyword">if</span> (stashY + stashHeight &gt; cellHeight) stashY = cellHeight - stashHeight;
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-73">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-73">&#x00a7;</a>
              </div>
              <p>Get the imageData object, and stash it</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        engine.save();
        engine.setTransform(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);
        <span class="hljs-built_in">this</span>.stashedImageData = engine.getImageData(stashX, stashY, stashWidth, stashHeight);
        engine.restore();</pre></div></div>
            
        </li>
        
        
        <li id="section-74">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-74">&#x00a7;</a>
              </div>
              <p>Get the dataUrl String, updating the stashed &lt;img&gt; element with it</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.stashOutputAsAsset) {

            <span class="hljs-built_in">this</span>.stashOutputAsAsset = <span class="hljs-literal">false</span>;

            <span class="hljs-keyword">let</span> sourcecanvas, mycanvas;
                
            mycanvas = requestCell();
            sourcecanvas = mycanvas.element;

            sourcecanvas.width = stashWidth;
            sourcecanvas.height = stashHeight;

            mycanvas.engine.putImageData(<span class="hljs-built_in">this</span>.stashedImageData, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);

            <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">this</span>.stashedImage) {

                <span class="hljs-keyword">let</span> newimg = <span class="hljs-built_in">this</span>.stashedImage = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&#x27;img&#x27;</span>);

                newimg.id = <span class="hljs-string">`<span class="hljs-subst">${<span class="hljs-built_in">this</span>.name}</span>-image`</span>;

                newimg.onload = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{

                    scrawlCanvasHold.appendChild(newimg);
                    importDomImage(<span class="hljs-string">`#<span class="hljs-subst">${newimg.id}</span>`</span>);
                };

                newimg.src = sourcecanvas.toDataURL();
            }
            <span class="hljs-keyword">else</span> <span class="hljs-built_in">this</span>.stashedImage.src = sourcecanvas.toDataURL();

            releaseCell(mycanvas);
        }
    }
};</pre></div></div>
            
        </li>
        
        
        <li id="section-75">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-75">&#x00a7;</a>
              </div>
              <p><code>getHost</code> - Internal function - get a reference to the Cell’s current host (where it will be stamping itself as part of the Display cycle).</p>
<ul>
<li>Note that Cells can (in theory: not tested yet) belong to more than one Canvas object Group - they can be used in multiple &lt;canvas&gt; elements, thus the need to check which canvas is the current host at this point in the Display cycle.</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>P.getHost = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{

    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.currentHost) <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.currentHost;
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.host) {

        <span class="hljs-keyword">let</span> host = asset[<span class="hljs-built_in">this</span>.host] || artefact[<span class="hljs-built_in">this</span>.host];

        <span class="hljs-keyword">if</span> (host) <span class="hljs-built_in">this</span>.currentHost = host;
        
        <span class="hljs-keyword">return</span> (host) ? <span class="hljs-built_in">this</span>.currentHost : <span class="hljs-literal">false</span>;
    }
    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
};</pre></div></div>
            
        </li>
        
        
        <li id="section-76">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-76">&#x00a7;</a>
              </div>
              <p><code>updateBaseHere</code> - Internal function - keeping the Canvas object’s ‘base’ Cell’s <code>.here</code> attribute up-to-date with accurate mouse/pointer/touch cursor data</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>P.updateBaseHere = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">controllerHere, fit</span>) </span>{

    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.isBase) {

        <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">this</span>.here) <span class="hljs-built_in">this</span>.here = {};
        <span class="hljs-keyword">let</span> here = <span class="hljs-built_in">this</span>.here,
            dims = <span class="hljs-built_in">this</span>.currentDimensions;

        <span class="hljs-keyword">let</span> active = controllerHere.active;

        <span class="hljs-keyword">let</span> controllerWidth = (controllerHere.localListener) ? controllerHere.originalWidth : controllerHere.w;
        <span class="hljs-keyword">let</span> controllerHeight = (controllerHere.localListener) ? controllerHere.originalHeight : controllerHere.h;

        <span class="hljs-keyword">if</span> (dims[<span class="hljs-number">0</span>] !== controllerWidth || dims[<span class="hljs-number">1</span>] !== controllerHeight) {

            <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">this</span>.basePaste) <span class="hljs-built_in">this</span>.basePaste = [];

            <span class="hljs-keyword">let</span> pasteX = <span class="hljs-built_in">this</span>.basePaste[<span class="hljs-number">0</span>];

            <span class="hljs-keyword">let</span> localWidth = dims[<span class="hljs-number">0</span>],
                localHeight = dims[<span class="hljs-number">1</span>],
                remoteWidth = controllerWidth,
                remoteHeight = controllerHeight,
                remoteX = controllerHere.x,
                remoteY = controllerHere.y;

            <span class="hljs-keyword">let</span> relWidth = localWidth / remoteWidth || <span class="hljs-number">1</span>,
                relHeight = localHeight / remoteHeight || <span class="hljs-number">1</span>,
                round = <span class="hljs-built_in">Math</span>.round,
                offsetX, offsetY;

            here.w = localWidth;
            here.h = localHeight;

            <span class="hljs-keyword">switch</span> (fit) {

                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;contain&#x27;</span> :
                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;cover&#x27;</span> :

                    <span class="hljs-keyword">if</span> (pasteX) {

                        offsetX = (remoteWidth - (localWidth / relHeight)) / <span class="hljs-number">2</span>;

                        here.x = round((remoteX - offsetX) * relHeight);
                        here.y = round(remoteY * relHeight);
                    }
                    <span class="hljs-keyword">else</span> {

                        offsetY = (remoteHeight - (localHeight / relWidth)) / <span class="hljs-number">2</span>;

                        here.x = round(remoteX * relWidth);
                        here.y = round((remoteY - offsetY) * relWidth);
                    }
                    <span class="hljs-keyword">break</span>;

                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;fill&#x27;</span> :
                    here.x = round(remoteX * relWidth);
                    here.y = round(remoteY * relHeight);
                    <span class="hljs-keyword">break</span>;

                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;none&#x27;</span> :
                <span class="hljs-keyword">default</span> :
                    offsetX = (remoteWidth - localWidth) / <span class="hljs-number">2</span>;
                    offsetY = (remoteHeight - localHeight) / <span class="hljs-number">2</span>;

                    here.x = round(remoteX - offsetX);
                    here.y = round(remoteY - offsetY);
            }

            <span class="hljs-keyword">if</span> (here.x &lt; <span class="hljs-number">0</span> || here.x &gt; localWidth) active = <span class="hljs-literal">false</span>;
            <span class="hljs-keyword">if</span> (here.y &lt; <span class="hljs-number">0</span> || here.y &gt; localHeight) active = <span class="hljs-literal">false</span>;

            here.active = active;
        }
        <span class="hljs-keyword">else</span> {

            here.x = controllerHere.x;
            here.y = controllerHere.y;
            here.w = controllerWidth;
            here.h = controllerHeight;
            here.active = active;
        }
        controllerHere.baseActive = active;
    }
};</pre></div></div>
            
        </li>
        
        
        <li id="section-77">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-77">&#x00a7;</a>
              </div>
              <p><code>prepareStamp</code> - Internal function - steps to be performed before the Cell stamps its visual contents onto a Canvas object’s base cell’s canvas. Will be invoked as part of the Display cycle ‘show’ functionality.</p>
<ul>
<li>Cells can emulate (much of) the functionality of entity artefacts, in that they can be positioned (start, handle, offset), rotated, scaled and flipped when they stamp themselves on the base cell. They can also be positioned using mimic, pivot, path and mouse functionality.</li>
<li>Cells cannot be included in Group objects (which only accept artefacts as members); however drag-and-drop functionality can be emulated by creating a Block and pivot/mimic the Cell to that. Similarly, Block substitutes can be used for hover detection, with their hook functions tailored to pass on the required response to the Cell - see Demo <a href="../../demo/canvas-036.html">Canvas-036</a>.</li>
<li>Note that Cells acting as a Canvas object’s ‘base’ cell will position themselves on the displayed Canvas in line with their Canvas controller’s ‘fit’ attribute, disregarding any positional information it may have been given.</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>P.prepareStamp = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{

    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.dirtyScale || <span class="hljs-built_in">this</span>.dirtyDimensions || <span class="hljs-built_in">this</span>.dirtyStart || <span class="hljs-built_in">this</span>.dirtyOffset || <span class="hljs-built_in">this</span>.dirtyHandle) <span class="hljs-built_in">this</span>.dirtyPathObject = <span class="hljs-literal">true</span>;

    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.dirtyScale) <span class="hljs-built_in">this</span>.cleanScale();

    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.dirtyDimensions) {

        <span class="hljs-built_in">this</span>.cleanDimensions();
        <span class="hljs-built_in">this</span>.dirtyAssetSubscribers = <span class="hljs-literal">true</span>;
    }

    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.dirtyLock) <span class="hljs-built_in">this</span>.cleanLock();
    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.dirtyStart) <span class="hljs-built_in">this</span>.cleanStart();
    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.dirtyOffset) <span class="hljs-built_in">this</span>.cleanOffset();
    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.dirtyHandle) <span class="hljs-built_in">this</span>.cleanHandle();
    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.dirtyRotation) <span class="hljs-built_in">this</span>.cleanRotation();

    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.isBeingDragged || <span class="hljs-built_in">this</span>.lockTo.indexOf(<span class="hljs-string">&#x27;mouse&#x27;</span>) &gt;= <span class="hljs-number">0</span>) {

        <span class="hljs-built_in">this</span>.dirtyStampPositions = <span class="hljs-literal">true</span>;
        <span class="hljs-built_in">this</span>.dirtyStampHandlePositions = <span class="hljs-literal">true</span>;
    }

    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.dirtyStampPositions) <span class="hljs-built_in">this</span>.cleanStampPositions();
    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.dirtyStampHandlePositions) <span class="hljs-built_in">this</span>.cleanStampHandlePositions();

    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.dirtyPathObject) <span class="hljs-built_in">this</span>.cleanPathObject();

    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.dirtyPositionSubscribers) <span class="hljs-built_in">this</span>.updatePositionSubscribers();

    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.dirtyAssetSubscribers) {

        <span class="hljs-built_in">this</span>.dirtyAssetSubscribers = <span class="hljs-literal">false</span>;
        <span class="hljs-built_in">this</span>.notifySubscribers();
    }
};</pre></div></div>
            
        </li>
        
        
        <li id="section-78">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-78">&#x00a7;</a>
              </div>
              <p><code>cleanPathObject</code> - Calculate the Cell’s <strong>Path2D object</strong></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>P.cleanPathObject = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{

    <span class="hljs-built_in">this</span>.dirtyPathObject = <span class="hljs-literal">false</span>;

    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">this</span>.noPathUpdates || !<span class="hljs-built_in">this</span>.pathObject) {

        <span class="hljs-keyword">let</span> p = <span class="hljs-built_in">this</span>.pathObject = <span class="hljs-keyword">new</span> Path2D();
        
        <span class="hljs-keyword">let</span> handle = <span class="hljs-built_in">this</span>.currentStampHandlePosition,
            scale = <span class="hljs-built_in">this</span>.currentScale,
            dims = <span class="hljs-built_in">this</span>.currentDimensions;

        <span class="hljs-keyword">let</span> x = -handle[<span class="hljs-number">0</span>] * scale,
            y = -handle[<span class="hljs-number">1</span>] * scale,
            w = dims[<span class="hljs-number">0</span>] * scale,
            h = dims[<span class="hljs-number">1</span>] * scale;

        p.rect(x, y, w, h);
    }
};</pre></div></div>
            
        </li>
        
        
        <li id="section-79">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-79">&#x00a7;</a>
              </div>
              <p><code>updateHere</code> - Internal function - get the Cell to update its .here information</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>P.updateHere = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{

    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">this</span>.here) <span class="hljs-built_in">this</span>.here = {};

    <span class="hljs-keyword">let</span> localHere = <span class="hljs-built_in">this</span>.here;

    <span class="hljs-keyword">let</span> [width, height] = <span class="hljs-built_in">this</span>.currentDimensions;

    localHere.w = width;
    localHere.h = height;
    localHere.x = -<span class="hljs-number">10000</span>;
    localHere.y = -<span class="hljs-number">10000</span>;
    localHere.active = <span class="hljs-literal">false</span>;

    <span class="hljs-keyword">let</span> host = <span class="hljs-built_in">this</span>.currentHost;

    <span class="hljs-keyword">if</span> (host) {

        <span class="hljs-keyword">let</span> hostHere = host.here;

        <span class="hljs-keyword">if</span> (hostHere &amp;&amp; hostHere.active) {

            <span class="hljs-keyword">let</span> {<span class="hljs-attr">x</span>:hostX, <span class="hljs-attr">y</span>:hostY, <span class="hljs-attr">w</span>:hostWidth, <span class="hljs-attr">h</span>:hostHeight} = hostHere;

            <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">this</span>.pathObject || <span class="hljs-built_in">this</span>.dirtyPathObject) <span class="hljs-built_in">this</span>.cleanPathObject();

            <span class="hljs-keyword">let</span> tempCell = requestCell();
            <span class="hljs-keyword">let</span> tempEngine = tempCell.engine;

            <span class="hljs-keyword">let</span> [stampX, stampY] = <span class="hljs-built_in">this</span>.currentStampPosition;

            tempCell.rotateDestination(tempEngine, stampX, stampY, <span class="hljs-built_in">this</span>);

            <span class="hljs-keyword">let</span> active = tempEngine.isPointInPath(<span class="hljs-built_in">this</span>.pathObject, hostX, hostY);

            releaseCell(tempCell);

            localHere.active = active;

            <span class="hljs-keyword">if</span> (active) {

                <span class="hljs-keyword">let</span> [stampHandleX, stampHandleY] = <span class="hljs-built_in">this</span>.currentStampHandlePosition;

                <span class="hljs-keyword">let</span> {flipUpend, flipReverse, roll, scale} = <span class="hljs-built_in">this</span>;

                <span class="hljs-keyword">if</span> (scale) {

                    <span class="hljs-keyword">let</span> left = ((hostX - stampX) / scale),
                        top = ((hostY - stampY) / scale);

                    <span class="hljs-keyword">if</span> (flipReverse) left = -left;
                    <span class="hljs-keyword">if</span> (flipUpend) top = -top;

                    <span class="hljs-keyword">if</span> (roll) {

                        <span class="hljs-keyword">if</span> ((flipReverse &amp;&amp; !flipUpend) || (!flipReverse &amp;&amp; flipUpend)) roll = -roll;

                        <span class="hljs-keyword">let</span> coord = requestCoordinate(left, top);
                        coord.rotate(-roll);

                        [left, top] = coord;

                        releaseCoordinate(coord);
                    }

                    left += stampHandleX;
                    top += stampHandleY;

                    localHere.x = left;
                    localHere.y = top;
                }
            }
        }
    }
};</pre></div></div>
            
        </li>
        
        
        <li id="section-80">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-80">&#x00a7;</a>
              </div>
              <p><code>getEntityHits</code> - Returns an array of entity Objects responding ‘true’ to a checkHit call on them, for the Cell’s current <code>.here</code> attribute coordinates. Used in particular with <code>Canvas.cascadeEventAction()</code> function</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>P.getEntityHits = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{

    <span class="hljs-keyword">let</span> response = [],
        results = [],
        resultNames = [];

    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.groupBuckets) {

        <span class="hljs-built_in">this</span>.groupBuckets.forEach(<span class="hljs-function"><span class="hljs-params">grp</span> =&gt;</span> {
            <span class="hljs-keyword">if</span> (grp.visibility) results.push(grp.getAllArtefactsAt(<span class="hljs-built_in">this</span>.here));
        }, <span class="hljs-built_in">this</span>);
    }

    <span class="hljs-keyword">if</span> (results.length) {

        results = results.reduce(<span class="hljs-function">(<span class="hljs-params">a, v</span>) =&gt;</span> a.concat(v), []);

        results.forEach(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> {

            <span class="hljs-keyword">let</span> art = item.artefact;

            <span class="hljs-keyword">if</span> (art.visibility &amp;&amp; resultNames.indexOf(art.name) &lt; <span class="hljs-number">0</span>) {

                resultNames.push(art.name);
                response.push(art);
            }
        })
    }
    <span class="hljs-keyword">return</span> response;
};</pre></div></div>
            
        </li>
        
        
        <li id="section-81">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-81">&#x00a7;</a>
              </div>
              <p><code>rotateDestination</code> - internal function, called by entity objects about to stamp themselves onto the Cell.</p>
<ul>
<li>entity stamp functionality works by performing a <code>setTransform</code> action on the Cell engine so that engine coordinates [0, 0] equal the entity’s <code>currentStampPosition</code> coordinates, alongside any directionality (<code>flipReverse</code>, <code>flipUpend</code>) and rotational (<code>roll</code>) changes necessary</li>
<li>doing it this way saves a massive amount of calculation that is otherwise required to correctly position the entity in the display</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>P.rotateDestination = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">engine, x, y, entity</span>) </span>{

    <span class="hljs-keyword">let</span> self = (entity) ? entity : <span class="hljs-built_in">this</span>,
        mimic = self.mimic,
        pivot = self.pivot,
        reverse, upend,
        rotation = self.currentRotation;

    <span class="hljs-keyword">if</span> (mimic &amp;&amp; mimic.name &amp;&amp; self.useMimicFlip) {

        reverse = (mimic.flipReverse) ? -<span class="hljs-number">1</span> : <span class="hljs-number">1</span>;
        upend = (mimic.flipUpend) ? -<span class="hljs-number">1</span> : <span class="hljs-number">1</span>;
    }
    <span class="hljs-keyword">else</span> {

        reverse = (self.flipReverse) ? -<span class="hljs-number">1</span> : <span class="hljs-number">1</span>;
        upend = (self.flipUpend) ? -<span class="hljs-number">1</span> : <span class="hljs-number">1</span>;
    }

    <span class="hljs-keyword">if</span> (mimic &amp;&amp; mimic.name &amp;&amp; self.useMimicRotation) {

        rotation = mimic.currentRotation;
    }
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pivot &amp;&amp; pivot.name &amp;&amp; self.addPivotRotation) {

        rotation = pivot.currentRotation;
    }

    <span class="hljs-keyword">if</span> (rotation) {

        rotation *= radian;

        <span class="hljs-keyword">let</span> cos = <span class="hljs-built_in">Math</span>.cos(rotation),
            sin = <span class="hljs-built_in">Math</span>.sin(rotation);

        engine.setTransform((cos * reverse), (sin * reverse), (-sin * upend), (cos * upend), x, y);
    }
    <span class="hljs-keyword">else</span> engine.setTransform(reverse, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, upend, x, y);

    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;
};</pre></div></div>
            
        </li>
        
        
        <li id="section-82">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-82">&#x00a7;</a>
              </div>
              <h4 id="cell-pool">Cell pool</h4>
<p>A number of processes - for instance collision functionality, and applying filters to entitys and groups - require the use of a &lt;canvas&gt; element and its CanvasRenderingContext2D engine. Rather than generate these canvas elements on the fly, we store them in a pool, to help make the code more efficiant.</p>
<p>To use a pool cell, request it using the exposed <strong>requestCell</strong> function.</p>
<p>IT IS IMPERATIVE that requested cells are released once work with them completes, using the <strong>releaseCell</strong> function. Failure to do this leads to impaired performance as Javascript creates new canvas elements (often in multiples of 60 per second) which need to be garbage collected by the Javascript engine, thus leading to increasingly shoddy performance the longer the animation runs.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-keyword">const</span> cellPool = [];

P.poolDefs = {
    <span class="hljs-attr">element</span>: <span class="hljs-literal">null</span>,
    <span class="hljs-attr">engine</span>: <span class="hljs-literal">null</span>,
    <span class="hljs-attr">state</span>: <span class="hljs-literal">null</span>,
    <span class="hljs-attr">width</span>: <span class="hljs-number">300</span>,
    <span class="hljs-attr">height</span>: <span class="hljs-number">100</span>,
    <span class="hljs-attr">alpha</span>: <span class="hljs-number">1</span>,
    <span class="hljs-attr">composite</span>: <span class="hljs-string">&#x27;source-over&#x27;</span>,
}</pre></div></div>
            
        </li>
        
        
        <li id="section-83">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-83">&#x00a7;</a>
              </div>
              <p><code>Exported function</code> - <strong>requestCell</strong></p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-keyword">const</span> requestCell = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{

    <span class="hljs-keyword">if</span> (!cellPool.length) {

        cellPool.push(makeCell({
            <span class="hljs-attr">name</span>: <span class="hljs-string">`pool_<span class="hljs-subst">${generateUniqueString()}</span>`</span>,
            <span class="hljs-attr">isPool</span>: <span class="hljs-literal">true</span>
        }));
    }

    <span class="hljs-keyword">let</span> c = cellPool.shift();
    c.engine.save();
    <span class="hljs-keyword">return</span> c;
};</pre></div></div>
            
        </li>
        
        
        <li id="section-84">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-84">&#x00a7;</a>
              </div>
              <p><code>Exported function</code> - <strong>releaseCell</strong></p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-keyword">const</span> releaseCell = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">c</span>) </span>{

    <span class="hljs-keyword">if</span> (c &amp;&amp; c.type === <span class="hljs-string">&#x27;Cell&#x27;</span>) {

        c.engine.restore();
        cellPool.push(c);
    }
};</pre></div></div>
            
        </li>
        
        
        <li id="section-85">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-85">&#x00a7;</a>
              </div>
              <h4 id="factory">Factory</h4>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-keyword">const</span> makeCell = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">items</span>) </span>{

    <span class="hljs-keyword">if</span> (!items) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Cell(items);
};

<span class="hljs-title">constructors</span>.<span class="hljs-title">Cell</span> = <span class="hljs-title">Cell</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-86">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-86">&#x00a7;</a>
              </div>
              <h4 id="exports">Exports</h4>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-keyword">export</span> {
    makeCell,
    requestCell,
    releaseCell,
};</pre></div></div>
            
        </li>
        
    </ul>
  </div>
</body>
</html>
